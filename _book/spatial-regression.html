<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 14 Spatial Regression | Spatial Data Science</title>
  <meta name="description" content="description_xx" />
  <meta name="generator" content="bookdown 0.22 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 14 Spatial Regression | Spatial Data Science" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="description_xx" />
  <meta name="github-repo" content="edzer/sdsr" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 14 Spatial Regression | Spatial Data Science" />
  
  <meta name="twitter:description" content="description_xx" />
  

<meta name="author" content="Edzer Pebesma, Roger Bivand" />


<meta name="date" content="2021-05-24" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="area.html"/>
<link rel="next" href="sp-and-raster.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />









<link href="libs/anchor-sections-1.0.1/anchor-sections.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.0.1/anchor-sections.js"></script>
<script src="libs/htmlwidgets-1.5.3/htmlwidgets.js"></script>
<link href="libs/leaflet-1.3.1/leaflet.css" rel="stylesheet" />
<script src="libs/leaflet-1.3.1/leaflet.js"></script>
<link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet" />
<script src="libs/proj4-2.6.2/proj4.min.js"></script>
<script src="libs/Proj4Leaflet-1.0.1/proj4leaflet.js"></script>
<link href="libs/rstudio_leaflet-1.3.1/rstudio_leaflet.css" rel="stylesheet" />
<script src="libs/leaflet-binding-2.0.4.1/leaflet.js"></script>
<script src="libs/leaflet-providers-1.9.0/leaflet-providers_1.9.0.js"></script>
<script src="libs/leaflet-providers-plugin-2.0.4.1/leaflet-providers-plugin.js"></script>
<script src="libs/FlatGeoBuf-3.3.3/fgb.js"></script>
<script src="libs/FlatGeoBuf-3.3.3/flatgeobuf-geojson.min.js"></script>
<script src="libs/chromajs-2.1.0/chroma.min.js"></script>
<link id="nc_32119-BIR74-1-attachment" rel="attachment" href="libs/nc_32119-BIR74-0.0.1/nc_32119-BIR74_layer.fgb"/>
<link href="libs/HomeButton-0.0.1/home-button.css" rel="stylesheet" />
<script src="libs/HomeButton-0.0.1/home-button.js"></script>
<script src="libs/HomeButton-0.0.1/easy-button-src.min.js"></script>
<script src="libs/clipboard-0.0.1/setClipboardText.js"></script>
<link href="libs/mapviewCSS-0.0.1/mapview-popup.css" rel="stylesheet" />
<link href="libs/mapviewCSS-0.0.1/mapview.css" rel="stylesheet" />

<script>
/* ========================================================================
 * Bootstrap: transition.js v3.3.7
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);
</script>
<script>
/* ========================================================================
 * Bootstrap: collapse.js v3.3.7
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

/* jshint latedef: false */

+function ($) {
  'use strict';

  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element      = $(element)
    this.options       = $.extend({}, Collapse.DEFAULTS, options)
    this.$trigger      = $('[data-toggle="collapse"][href="#' + element.id + '"],' +
                           '[data-toggle="collapse"][data-target="#' + element.id + '"]')
    this.transitioning = null

    if (this.options.parent) {
      this.$parent = this.getParent()
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger)
    }

    if (this.options.toggle) this.toggle()
  }

  Collapse.VERSION  = '3.3.7'

  Collapse.TRANSITION_DURATION = 350

  Collapse.DEFAULTS = {
    toggle: true
  }

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width')
    return hasWidth ? 'width' : 'height'
  }

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return

    var activesData
    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')

    if (actives && actives.length) {
      activesData = actives.data('bs.collapse')
      if (activesData && activesData.transitioning) return
    }

    var startEvent = $.Event('show.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    if (actives && actives.length) {
      Plugin.call(actives, 'hide')
      activesData || actives.data('bs.collapse', null)
    }

    var dimension = this.dimension()

    this.$element
      .removeClass('collapse')
      .addClass('collapsing')[dimension](0)
      .attr('aria-expanded', true)

    this.$trigger
      .removeClass('collapsed')
      .attr('aria-expanded', true)

    this.transitioning = 1

    var complete = function () {
      this.$element
        .removeClass('collapsing')
        .addClass('collapse in')[dimension]('')
      this.transitioning = 0
      this.$element
        .trigger('shown.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    var scrollSize = $.camelCase(['scroll', dimension].join('-'))

    this.$element
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
  }

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return

    var startEvent = $.Event('hide.bs.collapse')
    this.$element.trigger(startEvent)
    if (startEvent.isDefaultPrevented()) return

    var dimension = this.dimension()

    this.$element[dimension](this.$element[dimension]())[0].offsetHeight

    this.$element
      .addClass('collapsing')
      .removeClass('collapse in')
      .attr('aria-expanded', false)

    this.$trigger
      .addClass('collapsed')
      .attr('aria-expanded', false)

    this.transitioning = 1

    var complete = function () {
      this.transitioning = 0
      this.$element
        .removeClass('collapsing')
        .addClass('collapse')
        .trigger('hidden.bs.collapse')
    }

    if (!$.support.transition) return complete.call(this)

    this.$element
      [dimension](0)
      .one('bsTransitionEnd', $.proxy(complete, this))
      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)
  }

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']()
  }

  Collapse.prototype.getParent = function () {
    return $(this.options.parent)
      .find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]')
      .each($.proxy(function (i, element) {
        var $element = $(element)
        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
      }, this))
      .end()
  }

  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass('in')

    $element.attr('aria-expanded', isOpen)
    $trigger
      .toggleClass('collapsed', !isOpen)
      .attr('aria-expanded', isOpen)
  }

  function getTargetFromTrigger($trigger) {
    var href
    var target = $trigger.attr('data-target')
      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') // strip for ie7

    return $(target)
  }


  // COLLAPSE PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.collapse')
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false
      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.collapse

  $.fn.collapse             = Plugin
  $.fn.collapse.Constructor = Collapse


  // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old
    return this
  }


  // COLLAPSE DATA-API
  // =================

  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var $this   = $(this)

    if (!$this.attr('data-target')) e.preventDefault()

    var $target = getTargetFromTrigger($this)
    var data    = $target.data('bs.collapse')
    var option  = data ? 'toggle' : $this.data()

    Plugin.call($target, option)
  })

}(jQuery);
</script>
<script>
window.initializeCodeFolding = function(show) {

  // handlers for show-all and hide all
  $("#rmd-show-all-code").click(function() {
    // close the dropdown menu when an option is clicked
    $("#allCodeButton").dropdown("toggle");
    $('div.r-code-collapse').each(function() {
      $(this).collapse('show');
    });
  });
  $("#rmd-hide-all-code").click(function() {
    // close the dropdown menu when an option is clicked
    $("#allCodeButton").dropdown("toggle");
    $('div.r-code-collapse').each(function() {
      $(this).collapse('hide');
    });
  });

  // index for unique code element ids
  var currentIndex = 1;

  // select all R code blocks
  var rCodeBlocks = $('pre.sourceCode, pre.r, pre.python, pre.bash, pre.sql, pre.cpp, pre.stan');
  rCodeBlocks.each(function() {

    // if code block has been labeled with class `fold-show`, show the code on init!
    var classList = $(this).attr('class').split(/\s+/);
    for (var i = 0; i < classList.length; i++) {
    if (classList[i] === 'fold-show') {
        show = true;
      }
    }

    // create a collapsable div to wrap the code in
    var div = $('<div class="collapse r-code-collapse"></div>');
    if (show)
      div.addClass('in');
    var id = 'rcode-643E0F36' + currentIndex++;
    div.attr('id', id);
    $(this).before(div);
    $(this).detach().appendTo(div);

    // add a show code button right above
    var showCodeText = $('<span>' + (show ? 'Hide' : 'Code') + '</span>');
    var showCodeButton = $('<button type="button" class="btn btn-default btn-xs code-folding-btn pull-right"></button>');
    showCodeButton.append(showCodeText);
    showCodeButton
        .attr('data-toggle', 'collapse')
        .attr('data-target', '#' + id)
        .attr('aria-expanded', show)
        .attr('aria-controls', id);

    var buttonRow = $('<div class="row"></div>');
    var buttonCol = $('<div class="col-md-12"></div>');

    buttonCol.append(showCodeButton);
    buttonRow.append(buttonCol);

    div.before(buttonRow);

    // hack: return show to false, otherwise all next codeBlocks will be shown!
    show = false;

    // update state of button on show/hide
    div.on('hidden.bs.collapse', function () {
      showCodeText.text('Code');
    });
    div.on('show.bs.collapse', function () {
      showCodeText.text('Hide');
    });
  });

}
</script>
<script>
/* ========================================================================
 * Bootstrap: dropdown.js v3.3.7
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2016 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop'
  var toggle   = '[data-toggle="dropdown"]'
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle)
  }

  Dropdown.VERSION = '3.3.7'

  function getParent($this) {
    var selector = $this.attr('data-target')

    if (!selector) {
      selector = $this.attr('href')
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '') // strip for ie7
    }

    var $parent = selector && $(selector)

    return $parent && $parent.length ? $parent : $this.parent()
  }

  function clearMenus(e) {
    if (e && e.which === 3) return
    $(backdrop).remove()
    $(toggle).each(function () {
      var $this         = $(this)
      var $parent       = getParent($this)
      var relatedTarget = { relatedTarget: this }

      if (!$parent.hasClass('open')) return

      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return

      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this.attr('aria-expanded', 'false')
      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))
    })
  }

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this)

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    clearMenus()

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $(document.createElement('div'))
          .addClass('dropdown-backdrop')
          .insertAfter($(this))
          .on('click', clearMenus)
      }

      var relatedTarget = { relatedTarget: this }
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))

      if (e.isDefaultPrevented()) return

      $this
        .trigger('focus')
        .attr('aria-expanded', 'true')

      $parent
        .toggleClass('open')
        .trigger($.Event('shown.bs.dropdown', relatedTarget))
    }

    return false
  }

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return

    var $this = $(this)

    e.preventDefault()
    e.stopPropagation()

    if ($this.is('.disabled, :disabled')) return

    var $parent  = getParent($this)
    var isActive = $parent.hasClass('open')

    if (!isActive && e.which != 27 || isActive && e.which == 27) {
      if (e.which == 27) $parent.find(toggle).trigger('focus')
      return $this.trigger('click')
    }

    var desc = ' li:not(.disabled):visible a'
    var $items = $parent.find('.dropdown-menu' + desc)

    if (!$items.length) return

    var index = $items.index(e.target)

    if (e.which == 38 && index > 0)                 index--         // up
    if (e.which == 40 && index < $items.length - 1) index++         // down
    if (!~index)                                    index = 0

    $items.eq(index).trigger('focus')
  }


  // DROPDOWN PLUGIN DEFINITION
  // ==========================

  function Plugin(option) {
    return this.each(function () {
      var $this = $(this)
      var data  = $this.data('bs.dropdown')

      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))
      if (typeof option == 'string') data[option].call($this)
    })
  }

  var old = $.fn.dropdown

  $.fn.dropdown             = Plugin
  $.fn.dropdown.Constructor = Dropdown


  // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old
    return this
  }


  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================

  $(document)
    .on('click.bs.dropdown.data-api', clearMenus)
    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })
    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)
    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)
    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)

}(jQuery);
</script>
<style type="text/css">
.code-folding-btn {
  margin-bottom: 4px;
}

.row { display: flex; }
.collapse { display: none; }
.in { display:block }
.pull-right > .dropdown-menu {
    right: 0;
    left: auto;
}

.dropdown-menu {
    position: absolute;
    top: 100%;
    left: 0;
    z-index: 1000;
    display: none;
    float: left;
    min-width: 160px;
    padding: 5px 0;
    margin: 2px 0 0;
    font-size: 14px;
    text-align: left;
    list-style: none;
    background-color: #fff;
    -webkit-background-clip: padding-box;
    background-clip: padding-box;
    border: 1px solid #ccc;
    border: 1px solid rgba(0,0,0,.15);
    border-radius: 4px;
    -webkit-box-shadow: 0 6px 12px rgba(0,0,0,.175);
    box-shadow: 0 6px 12px rgba(0,0,0,.175);
}

.open > .dropdown-menu {
    display: block;
    color: #ffffff;
    background-color: #ffffff;
    background-image: none;
    border-color: #92897e;
}

.dropdown-menu > li > a {
  display: block;
  padding: 3px 20px;
  clear: both;
  font-weight: 400;
  line-height: 1.42857143;
  color: #000000;
  white-space: nowrap;
}

.dropdown-menu > li > a:hover,
.dropdown-menu > li > a:focus {
  color: #ffffff;
  text-decoration: none;
  background-color: #e95420;
}

.dropdown-menu > .active > a,
.dropdown-menu > .active > a:hover,
.dropdown-menu > .active > a:focus {
  color: #ffffff;
  text-decoration: none;
  background-color: #e95420;
  outline: 0;
}
.dropdown-menu > .disabled > a,
.dropdown-menu > .disabled > a:hover,
.dropdown-menu > .disabled > a:focus {
  color: #aea79f;
}

.dropdown-menu > .disabled > a:hover,
.dropdown-menu > .disabled > a:focus {
  text-decoration: none;
  cursor: not-allowed;
  background-color: transparent;
  background-image: none;
  filter: progid:DXImageTransform.Microsoft.gradient(enabled = false);
}

.btn {
  display: inline-block;
  margin-bottom: 1;
  font-weight: normal;
  text-align: center;
  white-space: nowrap;
  vertical-align: middle;
  -ms-touch-action: manipulation;
      touch-action: manipulation;
  cursor: pointer;
  background-image: none;
  border: 1px solid transparent;
  padding: 4px 8px;
  font-size: 14px;
  line-height: 1.42857143;
  border-radius: 4px;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.btn:focus,
.btn:active:focus,
.btn.active:focus,
.btn.focus,
.btn:active.focus,
.btn.active.focus {
  outline: 5px auto -webkit-focus-ring-color;
  outline-offset: -2px;
}
.btn:hover,
.btn:focus,
.btn.focus {
  color: #ffffff;
  text-decoration: none;
}
.btn:active,
.btn.active {
  background-image: none;
  outline: 0;
  box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
}
.btn.disabled,
.btn[disabled],
fieldset[disabled] .btn {
  cursor: not-allowed;
  filter: alpha(opacity=65);
  opacity: 0.65;
  box-shadow: none;
}
a.btn.disabled,
fieldset[disabled] a.btn {
  pointer-events: none;
}
.btn-default {
  color: #ffffff;
  background-color: #aea79f; #important
  border-color: #aea79f;
}

.btn-default:focus,
.btn-default.focus {
  color: #ffffff;
  background-color: #978e83;
  border-color: #6f675e;
}

.btn-default:hover {
  color: #ffffff;
  background-color: #978e83;
  border-color: #92897e;
}
.btn-default:active,
.btn-default.active,
.btn-group > .btn:not(:first-child):not(:last-child):not(.dropdown-toggle) {
  border-radius: 0;
}
.btn-group > .btn:first-child {
  margin-left: 0;
}
.btn-group > .btn:first-child:not(:last-child):not(.dropdown-toggle) {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.btn-group > .btn:last-child:not(:first-child),
.btn-group > .dropdown-toggle:not(:first-child) {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}
.btn-group > .btn-group {
  float: left;
}
.btn-group > .btn-group:not(:first-child):not(:last-child) > .btn {
  border-radius: 0;
}
.btn-group > .btn-group:first-child:not(:last-child) > .btn:last-child,
.btn-group > .btn-group:first-child:not(:last-child) > .dropdown-toggle {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.btn-group > .btn-group:last-child:not(:first-child) > .btn:first-child {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}
.btn-group .dropdown-toggle:active,
.btn-group.open .dropdown-toggle {
  outline: 0;
}
.btn-group > .btn + .dropdown-toggle {
  padding-right: 8px;
  padding-left: 8px;
}
.btn-group > .btn-lg + .dropdown-toggle {
  padding-right: 12px;
  padding-left: 12px;
}
.btn-group.open .dropdown-toggle {
  box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
}
.btn-group.open .dropdown-toggle.btn-link {
  box-shadow: none;
}

</style>
<script>
var str = '<div class="btn-group pull-right" style="position: fixed; right: 50px; top: 10px; z-index: 200"><button type="button" class="btn btn-default btn-xs dropdown-toggle" id="allCodeButton" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true" data-_extension-text-contrast=""><span>Code</span> <span class="caret"></span></button><ul class="dropdown-menu" style="min-width: 50px;"><li><a id="rmd-show-all-code" href="#">Show All Code</a></li><li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li></ul></div>';
document.write(str);
</script>
<script>
$(document).ready(function () {
  window.initializeCodeFolding("show" === "hide");
});
</script>


<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Spatial Data Science</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="part"><span><b>I Spatial Data</b></span></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> Getting Started</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#a-first-map"><i class="fa fa-check"></i><b>1.1</b> A first map</a></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#coordinate-reference-systems"><i class="fa fa-check"></i><b>1.2</b> Coordinate reference systems</a></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#rasterize"><i class="fa fa-check"></i><b>1.3</b> Raster and vector data</a></li>
<li class="chapter" data-level="1.4" data-path="intro.html"><a href="intro.html#raster-types"><i class="fa fa-check"></i><b>1.4</b> Raster types</a></li>
<li class="chapter" data-level="1.5" data-path="intro.html"><a href="intro.html#time-series-arrays-data-cubes"><i class="fa fa-check"></i><b>1.5</b> Time series, arrays, data cubes</a></li>
<li class="chapter" data-level="1.6" data-path="intro.html"><a href="intro.html#support"><i class="fa fa-check"></i><b>1.6</b> Support</a></li>
<li class="chapter" data-level="1.7" data-path="intro.html"><a href="intro.html#spatial-data-science-software"><i class="fa fa-check"></i><b>1.7</b> Spatial data science software</a></li>
<li class="chapter" data-level="1.8" data-path="intro.html"><a href="intro.html#exercises"><i class="fa fa-check"></i><b>1.8</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="cs.html"><a href="cs.html"><i class="fa fa-check"></i><b>2</b> Coordinates</a><ul>
<li class="chapter" data-level="2.1" data-path="cs.html"><a href="cs.html#units"><i class="fa fa-check"></i><b>2.1</b> Quantities, units, datum</a></li>
<li class="chapter" data-level="2.2" data-path="cs.html"><a href="cs.html#ellipsoidal-coordinates"><i class="fa fa-check"></i><b>2.2</b> Ellipsoidal coordinates</a></li>
<li class="chapter" data-level="2.3" data-path="cs.html"><a href="cs.html#crs"><i class="fa fa-check"></i><b>2.3</b> Coordinate Reference Systems</a></li>
<li class="chapter" data-level="2.4" data-path="intro.html"><a href="intro.html#proj"><i class="fa fa-check"></i><b>2.4</b> PROJ and mapping accuracy</a></li>
<li class="chapter" data-level="2.5" data-path="cs.html"><a href="cs.html#wkt2"><i class="fa fa-check"></i><b>2.5</b> WKT-2</a></li>
<li class="chapter" data-level="2.6" data-path="cs.html"><a href="cs.html#exercises-1"><i class="fa fa-check"></i><b>2.6</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="geometries.html"><a href="geometries.html"><i class="fa fa-check"></i><b>3</b> Geometries</a><ul>
<li class="chapter" data-level="3.1" data-path="geometries.html"><a href="geometries.html#simplefeatures"><i class="fa fa-check"></i><b>3.1</b> Simple feature geometries</a></li>
<li class="chapter" data-level="3.2" data-path="geometries.html"><a href="geometries.html#opgeom"><i class="fa fa-check"></i><b>3.2</b> Operations on geometries</a></li>
<li class="chapter" data-level="3.3" data-path="geometries.html"><a href="geometries.html#precision"><i class="fa fa-check"></i><b>3.3</b> Precision</a></li>
<li class="chapter" data-level="3.4" data-path="geometries.html"><a href="geometries.html#coverages"><i class="fa fa-check"></i><b>3.4</b> Coverages: tessellations and rasters</a></li>
<li class="chapter" data-level="3.5" data-path="geometries.html"><a href="geometries.html#networks"><i class="fa fa-check"></i><b>3.5</b> Networks</a></li>
<li class="chapter" data-level="3.6" data-path="geometries.html"><a href="geometries.html#exercises-2"><i class="fa fa-check"></i><b>3.6</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="spherical.html"><a href="spherical.html"><i class="fa fa-check"></i><b>4</b> Spherical Geometries</a><ul>
<li class="chapter" data-level="4.1" data-path="spherical.html"><a href="spherical.html#straight-lines"><i class="fa fa-check"></i><b>4.1</b> Straight lines</a></li>
<li class="chapter" data-level="4.2" data-path="spherical.html"><a href="spherical.html#ring-direction"><i class="fa fa-check"></i><b>4.2</b> Ring direction</a></li>
<li class="chapter" data-level="4.3" data-path="spherical.html"><a href="spherical.html#full-polygon"><i class="fa fa-check"></i><b>4.3</b> Full polygon</a></li>
<li class="chapter" data-level="4.4" data-path="spherical.html"><a href="spherical.html#bounding-box-rectangle-and-cap"><i class="fa fa-check"></i><b>4.4</b> Bounding box, rectangle, and cap</a></li>
<li class="chapter" data-level="4.5" data-path="spherical.html"><a href="spherical.html#validity-on-the-sphere"><i class="fa fa-check"></i><b>4.5</b> Validity on the sphere</a></li>
<li class="chapter" data-level="4.6" data-path="spherical.html"><a href="spherical.html#exercises-3"><i class="fa fa-check"></i><b>4.6</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="featureattributes.html"><a href="featureattributes.html"><i class="fa fa-check"></i><b>5</b> Attributes and Support</a><ul>
<li class="chapter" data-level="5.1" data-path="featureattributes.html"><a href="featureattributes.html#agr"><i class="fa fa-check"></i><b>5.1</b> Attribute-geometry relationships and support</a></li>
<li class="chapter" data-level="5.2" data-path="featureattributes.html"><a href="featureattributes.html#aggregating-and-summarising"><i class="fa fa-check"></i><b>5.2</b> Aggregating and Summarising</a></li>
<li class="chapter" data-level="5.3" data-path="featureattributes.html"><a href="featureattributes.html#area-weighted"><i class="fa fa-check"></i><b>5.3</b> Area-weighted interpolation</a></li>
<li class="chapter" data-level="5.4" data-path="featureattributes.html"><a href="featureattributes.html#updownscaling"><i class="fa fa-check"></i><b>5.4</b> Up- and Downscaling</a></li>
<li class="chapter" data-level="5.5" data-path="featureattributes.html"><a href="featureattributes.html#exercises-4"><i class="fa fa-check"></i><b>5.5</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="datacube.html"><a href="datacube.html"><i class="fa fa-check"></i><b>6</b> Data Cubes</a><ul>
<li class="chapter" data-level="6.1" data-path="datacube.html"><a href="datacube.html#a-four-dimensional-data-cube"><i class="fa fa-check"></i><b>6.1</b> A four-dimensional data cube</a></li>
<li class="chapter" data-level="6.2" data-path="datacube.html"><a href="datacube.html#dimensions-attributes-and-support"><i class="fa fa-check"></i><b>6.2</b> Dimensions, attributes, and support</a></li>
<li class="chapter" data-level="6.3" data-path="datacube.html"><a href="datacube.html#dcoperations"><i class="fa fa-check"></i><b>6.3</b> Operations on data cubes</a></li>
<li class="chapter" data-level="6.4" data-path="datacube.html"><a href="datacube.html#vectordatacubes"><i class="fa fa-check"></i><b>6.4</b> Aggregating raster to vector cubes</a></li>
<li class="chapter" data-level="6.5" data-path="datacube.html"><a href="datacube.html#switching"><i class="fa fa-check"></i><b>6.5</b> Switching dimension with attributes</a></li>
<li class="chapter" data-level="6.6" data-path="datacube.html"><a href="datacube.html#otherdynamic"><i class="fa fa-check"></i><b>6.6</b> Other dynamic data</a></li>
<li class="chapter" data-level="6.7" data-path="datacube.html"><a href="datacube.html#exercises-5"><i class="fa fa-check"></i><b>6.7</b> Exercises</a></li>
</ul></li>
<li class="part"><span><b>II R for Spatial Data Science</b></span></li>
<li class="chapter" data-level="7" data-path="sf.html"><a href="sf.html"><i class="fa fa-check"></i><b>7</b> Introduction to sf and stars</a><ul>
<li class="chapter" data-level="7.1" data-path="sf.html"><a href="sf.html#sfintro"><i class="fa fa-check"></i><b>7.1</b> Package <code>sf</code></a></li>
<li class="chapter" data-level="7.2" data-path="sf.html"><a href="sf.html#spatial-joins"><i class="fa fa-check"></i><b>7.2</b> Spatial joins</a></li>
<li class="chapter" data-level="7.3" data-path="sf.html"><a href="sf.html#package-stars"><i class="fa fa-check"></i><b>7.3</b> Package <code>stars</code></a></li>
<li class="chapter" data-level="7.4" data-path="sf.html"><a href="sf.html#vector-data-cube-examples"><i class="fa fa-check"></i><b>7.4</b> Vector data cube examples</a></li>
<li class="chapter" data-level="7.5" data-path="sf.html"><a href="sf.html#raster-to-vector"><i class="fa fa-check"></i><b>7.5</b> raster-to-vector, vector-to-raster</a></li>
<li class="chapter" data-level="7.6" data-path="sf.html"><a href="sf.html#projsf"><i class="fa fa-check"></i><b>7.6</b> Coordinate transformations and conversions</a></li>
<li class="chapter" data-level="7.7" data-path="sf.html"><a href="sf.html#warp"><i class="fa fa-check"></i><b>7.7</b> transforming and warping rasters</a></li>
<li class="chapter" data-level="7.8" data-path="sf.html"><a href="sf.html#exercises-6"><i class="fa fa-check"></i><b>7.8</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="large.html"><a href="large.html"><i class="fa fa-check"></i><b>8</b> Large data sets</a><ul>
<li class="chapter" data-level="8.1" data-path="large.html"><a href="large.html#largesf"><i class="fa fa-check"></i><b>8.1</b> Vector data: <code>sf</code></a></li>
<li class="chapter" data-level="8.2" data-path="large.html"><a href="large.html#raster-data-stars"><i class="fa fa-check"></i><b>8.2</b> Raster data: <code>stars</code></a></li>
<li class="chapter" data-level="8.3" data-path="large.html"><a href="large.html#very-large-data-cubes"><i class="fa fa-check"></i><b>8.3</b> Very large data cubes</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="plotting.html"><a href="plotting.html"><i class="fa fa-check"></i><b>9</b> Plotting spatial data</a><ul>
<li class="chapter" data-level="9.1" data-path="plotting.html"><a href="plotting.html#transform"><i class="fa fa-check"></i><b>9.1</b> Every plot is a projection</a></li>
<li class="chapter" data-level="9.2" data-path="plotting.html"><a href="plotting.html#plotting-points-lines-polygons-grid-cells"><i class="fa fa-check"></i><b>9.2</b> Plotting points, lines, polygons, grid cells</a></li>
<li class="chapter" data-level="9.3" data-path="plotting.html"><a href="plotting.html#base-plot"><i class="fa fa-check"></i><b>9.3</b> Base <code>plot</code></a></li>
<li class="chapter" data-level="9.4" data-path="plotting.html"><a href="plotting.html#maps-with-ggplot2"><i class="fa fa-check"></i><b>9.4</b> Maps with <code>ggplot2</code></a></li>
<li class="chapter" data-level="9.5" data-path="plotting.html"><a href="plotting.html#tmap"><i class="fa fa-check"></i><b>9.5</b> Maps with <code>tmap</code></a></li>
<li class="chapter" data-level="9.6" data-path="plotting.html"><a href="plotting.html#interactive-maps-leaflet-mapview-tmap"><i class="fa fa-check"></i><b>9.6</b> Interactive maps: <code>leaflet</code>, <code>mapview</code>, <code>tmap</code></a></li>
</ul></li>
<li class="part"><span><b>III Models for Spatial Data</b></span></li>
<li class="chapter" data-level="10" data-path="statistical-modelling-of-spatial-data.html"><a href="statistical-modelling-of-spatial-data.html"><i class="fa fa-check"></i><b>10</b> Statistical modelling of spatial data</a><ul>
<li class="chapter" data-level="10.1" data-path="statistical-modelling-of-spatial-data.html"><a href="statistical-modelling-of-spatial-data.html#design"><i class="fa fa-check"></i><b>10.1</b> Design-based and model-based inference</a></li>
<li class="chapter" data-level="10.2" data-path="statistical-modelling-of-spatial-data.html"><a href="statistical-modelling-of-spatial-data.html#predictive-models-with-coordinates"><i class="fa fa-check"></i><b>10.2</b> Predictive models with coordinates</a></li>
<li class="chapter" data-level="10.3" data-path="statistical-modelling-of-spatial-data.html"><a href="statistical-modelling-of-spatial-data.html#model-based-inference"><i class="fa fa-check"></i><b>10.3</b> Model-based inference</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="pointpatterns.html"><a href="pointpatterns.html"><i class="fa fa-check"></i><b>11</b> Point Pattern Analysis</a></li>
<li class="chapter" data-level="12" data-path="interpolation.html"><a href="interpolation.html"><i class="fa fa-check"></i><b>12</b> Interpolation and Geostatistics</a><ul>
<li class="chapter" data-level="12.1" data-path="interpolation.html"><a href="interpolation.html#preparing-the-air-quality-dataset"><i class="fa fa-check"></i><b>12.1</b> Preparing the air quality dataset</a></li>
<li class="chapter" data-level="12.2" data-path="interpolation.html"><a href="interpolation.html#sample-variogram"><i class="fa fa-check"></i><b>12.2</b> Sample variogram</a></li>
<li class="chapter" data-level="12.3" data-path="interpolation.html"><a href="interpolation.html#fitting-variogram-models"><i class="fa fa-check"></i><b>12.3</b> Fitting variogram models</a></li>
<li class="chapter" data-level="12.4" data-path="interpolation.html"><a href="interpolation.html#kriging"><i class="fa fa-check"></i><b>12.4</b> Kriging interpolation</a></li>
<li class="chapter" data-level="12.5" data-path="interpolation.html"><a href="interpolation.html#blockkriging"><i class="fa fa-check"></i><b>12.5</b> Areal means: block kriging</a></li>
<li class="chapter" data-level="12.6" data-path="interpolation.html"><a href="interpolation.html#conditional-simulation"><i class="fa fa-check"></i><b>12.6</b> Conditional simulation</a></li>
<li class="chapter" data-level="12.7" data-path="interpolation.html"><a href="interpolation.html#trend-models"><i class="fa fa-check"></i><b>12.7</b> Trend models</a></li>
<li class="chapter" data-level="12.8" data-path="interpolation.html"><a href="interpolation.html#multivariable-geostatistics"><i class="fa fa-check"></i><b>12.8</b> Multivariable geostatistics</a></li>
<li class="chapter" data-level="12.9" data-path="interpolation.html"><a href="interpolation.html#spatiotemporal-interpolation"><i class="fa fa-check"></i><b>12.9</b> Spatiotemporal interpolation</a></li>
<li class="chapter" data-level="12.10" data-path="interpolation.html"><a href="interpolation.html#atpk"><i class="fa fa-check"></i><b>12.10</b> Area-to-point kriging</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="area.html"><a href="area.html"><i class="fa fa-check"></i><b>13</b> Area Data and Spatial Autocorrelation</a><ul>
<li class="chapter" data-level="13.1" data-path="area.html"><a href="area.html#spatial-autocorrelation"><i class="fa fa-check"></i><b>13.1</b> Spatial autocorrelation</a></li>
<li class="chapter" data-level="13.2" data-path="area.html"><a href="area.html#spatial-weight-matrices"><i class="fa fa-check"></i><b>13.2</b> Spatial weight matrices</a></li>
<li class="chapter" data-level="13.3" data-path="area.html"><a href="area.html#measures-of-spatial-autocorrelation"><i class="fa fa-check"></i><b>13.3</b> Measures of spatial autocorrelation</a></li>
</ul></li>
<li class="chapter" data-level="14" data-path="spatial-regression.html"><a href="spatial-regression.html"><i class="fa fa-check"></i><b>14</b> Spatial Regression</a><ul>
<li class="chapter" data-level="14.1" data-path="spatial-regression.html"><a href="spatial-regression.html#spatial-regression-with-spatial-weights"><i class="fa fa-check"></i><b>14.1</b> Spatial regression with spatial weights</a></li>
<li class="chapter" data-level="14.2" data-path="spatial-regression.html"><a href="spatial-regression.html#estimators"><i class="fa fa-check"></i><b>14.2</b> Estimators</a></li>
<li class="chapter" data-level="14.3" data-path="spatial-regression.html"><a href="spatial-regression.html#implementation-details"><i class="fa fa-check"></i><b>14.3</b> Implementation details</a></li>
<li class="chapter" data-level="14.4" data-path="spatial-regression.html"><a href="spatial-regression.html#markov-random-field-and-multilevel-models-with-spatial-weights"><i class="fa fa-check"></i><b>14.4</b> Markov random field and multilevel models with spatial weights</a></li>
</ul></li>
<li class="chapter" data-level="15" data-path="sp-and-raster.html"><a href="sp-and-raster.html"><i class="fa fa-check"></i><b>15</b> sp and raster</a><ul>
<li class="chapter" data-level="15.1" data-path="sp-and-raster.html"><a href="sp-and-raster.html#links-and-differences-between-sf-and-sp"><i class="fa fa-check"></i><b>15.1</b> links and differences between sf and sp</a></li>
<li class="chapter" data-level="15.2" data-path="sp-and-raster.html"><a href="sp-and-raster.html#migration-packages"><i class="fa fa-check"></i><b>15.2</b> migration packages</a></li>
<li class="chapter" data-level="15.3" data-path="sp-and-raster.html"><a href="sp-and-raster.html#raster-stars-and-sf"><i class="fa fa-check"></i><b>15.3</b> raster, stars and sf</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="all-r-code-in-this-book.html"><a href="all-r-code-in-this-book.html"><i class="fa fa-check"></i>All R code in this book</a></li>
<li class="chapter" data-level="" data-path="r-basics.html"><a href="r-basics.html"><i class="fa fa-check"></i>R basics</a><ul>
<li class="chapter" data-level="" data-path="r-basics.html"><a href="r-basics.html#pipes"><i class="fa fa-check"></i>Pipes</a></li>
<li class="chapter" data-level="15.4" data-path="r-basics.html"><a href="r-basics.html#data-structures"><i class="fa fa-check"></i><b>15.4</b> Data structures</a></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Spatial Data Science</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="spatial-regression" class="section level1">
<h1><span class="header-section-number">Chapter 14</span> Spatial Regression</h1>
<p>Even though it may be tempting to focus on interpreting the map pattern of an area support response variable of interest, the pattern may largely derive from covariates (and their functional forms), as well as the respective spatial footprints of the variables in play. Spatial autoregressive models in two dimensions began without covariates and with clear links to time series <span class="citation">(Whittle <a href="#ref-whittle:54">1954</a>)</span>. Extensions included tests for spatial autocorrelation in linear model residuals, and models applying the autoregressive component to the response or the residuals, where the latter matched the tests for residuals <span class="citation">(Cliff and Ord <a href="#ref-CliffOrd:72">1972</a>, <a href="#ref-cliff+ord:73">1973</a>)</span>. These “lattice” models of areal data typically express the dependence between observations using a graph of neighbours in the form of a contiguity matrix.</p>
<p>A division has grown up, possibly unhelpfully, between scientific fields using conditional autoregressive (CAR) models <span class="citation">(Besag <a href="#ref-besag:74">1974</a>)</span>, and simultaneous autoregressive models (SAR) <span class="citation">(Ord <a href="#ref-ord:75">1975</a>; Hepple <a href="#ref-hepple:76">1976</a>)</span>. Although CAR and SAR models are closely related, these fields have found it difficult to share experience of applying similar models, often despite referring to key work summarising the models <span class="citation">(Ripley <a href="#ref-ripley:81">1981</a>, <a href="#ref-ripley:88">1988</a>; Cressie <a href="#ref-Cressie:1993">1993</a>)</span>. Ripley gives the SAR variance as <span class="citation">(<a href="#ref-ripley:81">1981</a>, 89)</span>:</p>
<p><span class="math display">\[
{\rm Var}_S = \sigma^ 2(I-\lambda W_S)^{-1} (I-\lambda W_S^{\rm
T})^{-1}
\]</span>
where <span class="math inline">\(\lambda\)</span> is a spatial autocorrelation parameter and <span class="math inline">\(W_S\)</span> is a nonsingular matrix that represents spatial dependence. The CAR variance is:</p>
<p><span class="math display">\[
{\rm Var}_C = \sigma^ 2(I-\lambda W_C)^{-1}
\]</span>
where and <span class="math inline">\(W_C\)</span> is a symmetric and strictly positive definite matrix</p>
<p>More recent books expounding the theoretical bases for modelling with areal data simply point out the similarities in relevant chapters <span class="citation">(Gaetan and Guyon <a href="#ref-gaetan+guyon:10">2010</a>; Lieshout <a href="#ref-vanlieshout:19">2019</a>)</span>; the interested reader is invited to consult these sources for background information and examples using the functions described below.</p>
<p>Of course, handling a spatial correlation structure in a generalised least squares model or a (generalised) linear or nonlinear mixed effects model such as those provided in the <strong>nlme</strong> and many other packages does not have to use a graph of neighbours <span class="citation">(Pinheiro and Bates <a href="#ref-R:Pinheiro+Bates:2000">2000</a>)</span>. These models are also spatial regression models, using functions of the distance between observations, and fitted variograms to model the spatial autocorrelation present; such models have been held to yield a clearer picture of the underlying processes <span class="citation">(Wall <a href="#ref-wall:04">2004</a>)</span>, building on geostatistics. For example, the <strong>glmmTMB</strong> package successfully uses this approach to spatial regression <span class="citation">(Brooks et al. <a href="#ref-brookesetal:17">2017</a>)</span>. Here we will only consider spatial regression using spatial weights, chiefly as implemented in the <strong>spatialreg</strong> package recently split out of the <strong>spdep</strong> package which had grown unnecessarily large, covering too many aspects of spatial dependence.</p>
<div id="spatial-regression-with-spatial-weights" class="section level2">
<h2><span class="header-section-number">14.1</span> Spatial regression with spatial weights</h2>
<p>Spatial autoregression models using spatial weights matrices were described in some detail using maximum likelihood estimation some time ago <span class="citation">(Cliff and Ord <a href="#ref-cliff+ord:73">1973</a>, <a href="#ref-cliff+ord:81">1981</a>)</span>. A family of models were elaborated in spatial econometric terms extending earlier work, and in many cases using the simultaneous autoregressive framework and row standardization of spatial weights <span class="citation">(Anselin <a href="#ref-a88">1988</a>)</span>. The simultaneous and conditional autoregressive frameworks can be compared, and both can be supplemented using case weights to reflect the relative importance of different observations <span class="citation">(Waller and Gotway <a href="#ref-WallerGotway:2004">2004</a>)</span>.</p>
<p>Here we shall use the Boston housing data set, which has been restructured and furnished with census tract boundaries <span class="citation">(R. Bivand <a href="#ref-bivand17">2017</a>)</span>. The original data set used 506 census tracts and a hedonic model to try to estimate willingness to pay for clean air. The response was constructed from counts of ordinal answers to a 1970 census question about house value; the response is left and right censored in the census source. The key covariate was created from a calibrated meteorological model showing the annual nitrogen oxides (NOX) level for a smaller number of model output zones. The numbers of houses responding also varies by tract and model output zone. There are several other covariates, some measured at the tract level, some by town only, where towns broadly correspond to the air pollution model output zones.</p>
<div class="sourceCode" id="cb531"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb531-1" title="1"><span class="kw">library</span>(sf)</a>
<a class="sourceLine" id="cb531-2" title="2"><span class="kw">library</span>(spatialreg)</a></code></pre></div>
<pre><code># Loading required package: Matrix</code></pre>
<pre><code># 
# Attaching package: &#39;Matrix&#39;</code></pre>
<pre><code># The following objects are masked from &#39;package:tidyr&#39;:
# 
#     expand, pack, unpack</code></pre>
<pre><code># 
# Attaching package: &#39;spatialreg&#39;</code></pre>
<pre><code># The following objects are masked from &#39;package:spdep&#39;:
# 
#     as_dgRMatrix_listw, as_dsCMatrix_I, as_dsCMatrix_IrW,
#     as_dsTMatrix_listw, as.spam.listw, can.be.simmed, cheb_setup,
#     create_WX, do_ldet, eigen_pre_setup, eigen_setup, eigenw,
#     errorsarlm, get.ClusterOption, get.coresOption, get.mcOption,
#     get.VerboseOption, get.ZeroPolicyOption, GMargminImage, GMerrorsar,
#     griffith_sone, gstsls, Hausman.test, impacts, intImpacts,
#     Jacobian_W, jacobianSetup, l_max, lagmess, lagsarlm, lextrB,
#     lextrS, lextrW, lmSLX, LU_prepermutate_setup, LU_setup,
#     Matrix_J_setup, Matrix_setup, mcdet_setup, MCMCsamp, ME, mom_calc,
#     mom_calc_int2, moments_setup, powerWeights, sacsarlm,
#     SE_classic_setup, SE_interp_setup, SE_whichMin_setup,
#     set.ClusterOption, set.coresOption, set.mcOption,
#     set.VerboseOption, set.ZeroPolicyOption, similar.listw, spam_setup,
#     spam_update_setup, SpatialFiltering, spautolm, spBreg_err,
#     spBreg_lag, spBreg_sac, stsls, subgraph_eigenw, trW</code></pre>
<div class="sourceCode" id="cb537"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb537-1" title="1">boston_<span class="dv">506</span> &lt;-<span class="st"> </span><span class="kw">st_read</span>(<span class="kw">system.file</span>(<span class="st">&quot;shapes/boston_tracts.shp&quot;</span>, <span class="dt">package=</span><span class="st">&quot;spData&quot;</span>)[<span class="dv">1</span>])</a></code></pre></div>
<pre><code># Reading layer `boston_tracts&#39; from data source `/home/edzer/R/x86_64-pc-linux-gnu-library/4.0/spData/shapes/boston_tracts.shp&#39; using driver `ESRI Shapefile&#39;
# Simple feature collection with 506 features and 36 fields
# Geometry type: POLYGON
# Dimension:     XY
# Bounding box:  xmin: -71.5 ymin: 42 xmax: -70.6 ymax: 42.7
# Geodetic CRS:  NAD27</code></pre>
<div class="sourceCode" id="cb539"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb539-1" title="1">nb_q &lt;-<span class="st"> </span>spdep<span class="op">::</span><span class="kw">poly2nb</span>(boston_<span class="dv">506</span>)</a>
<a class="sourceLine" id="cb539-2" title="2">lw_q &lt;-<span class="st"> </span>spdep<span class="op">::</span><span class="kw">nb2listw</span>(nb_q, <span class="dt">style=</span><span class="st">&quot;W&quot;</span>)</a></code></pre></div>
<p>We can start by reading in the 506 tract data set from <strong>spData</strong>, and creating a contiguity neighbour object and from that again a row standardized spatial weights object. If we examine the median house values, we find that they have been assigned as missing values, and that 17 tracts are affected.</p>
<div class="sourceCode" id="cb540"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb540-1" title="1"><span class="kw">table</span>(boston_<span class="dv">506</span><span class="op">$</span>censored)</a></code></pre></div>
<pre><code># 
#  left    no right 
#     2   489    15</code></pre>
<div class="sourceCode" id="cb542"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb542-1" title="1"><span class="kw">summary</span>(boston_<span class="dv">506</span><span class="op">$</span>median)</a></code></pre></div>
<pre><code>#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA&#39;s 
#    5600   16800   21000   21749   24700   50000      17</code></pre>
<p>Next, we can subset to the remaining 489 tracts with non-censored house values, and the neighbour object to match. The neighbour object now has one observation with no neighbours.</p>
<div class="sourceCode" id="cb544"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb544-1" title="1">boston_<span class="dv">489</span> &lt;-<span class="st"> </span>boston_<span class="dv">506</span>[<span class="op">!</span><span class="kw">is.na</span>(boston_<span class="dv">506</span><span class="op">$</span>median),]</a>
<a class="sourceLine" id="cb544-2" title="2">nb_q_<span class="dv">489</span> &lt;-<span class="st"> </span>spdep<span class="op">::</span><span class="kw">poly2nb</span>(boston_<span class="dv">489</span>)</a>
<a class="sourceLine" id="cb544-3" title="3">lw_q_<span class="dv">489</span> &lt;-<span class="st"> </span>spdep<span class="op">::</span><span class="kw">nb2listw</span>(nb_q_<span class="dv">489</span>, <span class="dt">style=</span><span class="st">&quot;W&quot;</span>, <span class="dt">zero.policy=</span><span class="ot">TRUE</span>)</a></code></pre></div>
<p>The <code>NOX_ID</code> variable specifies the upper level aggregation, letting us aggregate the tracts to air pollution model output zones. We can create aggregate neighbour and row standardized spatial weights objects, and aggregate the <code>NOX</code> variable taking means, and the <code>CHAS</code> Charles River dummy variable for observations on the river.</p>
<div class="sourceCode" id="cb545"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb545-1" title="1">agg_<span class="dv">96</span> &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="kw">as.character</span>(boston_<span class="dv">506</span><span class="op">$</span>NOX_ID))</a>
<a class="sourceLine" id="cb545-2" title="2">boston_<span class="dv">96</span> &lt;-<span class="st"> </span><span class="kw">aggregate</span>(boston_<span class="dv">506</span>[, <span class="st">&quot;NOX_ID&quot;</span>], <span class="dt">by=</span>agg_<span class="dv">96</span>, unique)</a>
<a class="sourceLine" id="cb545-3" title="3">nb_q_<span class="dv">96</span> &lt;-<span class="st"> </span>spdep<span class="op">::</span><span class="kw">poly2nb</span>(boston_<span class="dv">96</span>)</a>
<a class="sourceLine" id="cb545-4" title="4">lw_q_<span class="dv">96</span> &lt;-<span class="st"> </span>spdep<span class="op">::</span><span class="kw">nb2listw</span>(nb_q_<span class="dv">96</span>)</a>
<a class="sourceLine" id="cb545-5" title="5">boston_<span class="dv">96</span><span class="op">$</span>NOX &lt;-<span class="st"> </span><span class="kw">aggregate</span>(boston_<span class="dv">506</span><span class="op">$</span>NOX, agg_<span class="dv">96</span>, mean)<span class="op">$</span>x</a>
<a class="sourceLine" id="cb545-6" title="6">boston_<span class="dv">96</span><span class="op">$</span>CHAS &lt;-<span class="st"> </span><span class="kw">aggregate</span>(<span class="kw">as.integer</span>(boston_<span class="dv">506</span><span class="op">$</span>CHAS)<span class="op">-</span><span class="dv">1</span>, agg_<span class="dv">96</span>, max)<span class="op">$</span>x</a></code></pre></div>
<p>The response is aggregated using the <code>weightedMedian()</code> function in <strong>matrixStats</strong>, and midpoint values for the house value classes. Counts of houses by value class were punched to check the published census values, which can be replicated using <code>weightedMedian()</code> at the tract level. Here we find two output zones with calculated weighted medians over the upper census question limit of USD 50,000, and remove them subsequently as they also are affected by not knowing the appropriate value to insert for the top class by value.</p>
<div class="sourceCode" id="cb546"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb546-1" title="1">nms &lt;-<span class="st"> </span><span class="kw">names</span>(boston_<span class="dv">506</span>)</a>
<a class="sourceLine" id="cb546-2" title="2">ccounts &lt;-<span class="st"> </span><span class="dv">23</span><span class="op">:</span><span class="dv">31</span></a>
<a class="sourceLine" id="cb546-3" title="3"><span class="cf">for</span> (nm <span class="cf">in</span> nms[<span class="kw">c</span>(<span class="dv">22</span>, ccounts, <span class="dv">36</span>)]) {</a>
<a class="sourceLine" id="cb546-4" title="4">  boston_<span class="dv">96</span>[[nm]] &lt;-<span class="st"> </span><span class="kw">aggregate</span>(boston_<span class="dv">506</span>[[nm]], agg_<span class="dv">96</span>, sum)<span class="op">$</span>x</a>
<a class="sourceLine" id="cb546-5" title="5">}</a>
<a class="sourceLine" id="cb546-6" title="6">br2 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">3.50</span>,  <span class="fl">6.25</span>,  <span class="fl">8.75</span>, <span class="fl">12.50</span>, <span class="fl">17.50</span>, <span class="fl">22.50</span>, <span class="fl">30.00</span>, <span class="fl">42.50</span>, <span class="fl">60.00</span>)<span class="op">*</span><span class="dv">1000</span></a>
<a class="sourceLine" id="cb546-7" title="7">counts &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(boston_<span class="dv">96</span>)[, nms[ccounts]]</a>
<a class="sourceLine" id="cb546-8" title="8">f &lt;-<span class="st"> </span><span class="cf">function</span>(x) matrixStats<span class="op">::</span><span class="kw">weightedMedian</span>(<span class="dt">x=</span>br2, <span class="dt">w=</span>x, <span class="dt">interpolate=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb546-9" title="9">boston_<span class="dv">96</span><span class="op">$</span>median &lt;-<span class="st"> </span><span class="kw">apply</span>(counts, <span class="dv">1</span>, f)</a>
<a class="sourceLine" id="cb546-10" title="10"><span class="kw">is.na</span>(boston_<span class="dv">96</span><span class="op">$</span>median) &lt;-<span class="st"> </span>boston_<span class="dv">96</span><span class="op">$</span>median <span class="op">&gt;</span><span class="st"> </span><span class="dv">50000</span></a>
<a class="sourceLine" id="cb546-11" title="11"><span class="kw">summary</span>(boston_<span class="dv">96</span><span class="op">$</span>median)</a></code></pre></div>
<pre><code>#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA&#39;s 
#    9009   20417   23523   25263   30073   49496       2</code></pre>
<p>Before subsetting, we aggregate the remaining covariates by weighted mean using the tract population counts punched from the census <span class="citation">(R. Bivand <a href="#ref-bivand17">2017</a>)</span>.</p>
<div class="sourceCode" id="cb548"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb548-1" title="1">boston_<span class="dv">94</span> &lt;-<span class="st"> </span>boston_<span class="dv">96</span>[<span class="op">!</span><span class="kw">is.na</span>(boston_<span class="dv">96</span><span class="op">$</span>median),]</a>
<a class="sourceLine" id="cb548-2" title="2">nb_q_<span class="dv">94</span> &lt;-<span class="st"> </span>spdep<span class="op">::</span><span class="kw">subset.nb</span>(nb_q_<span class="dv">96</span>, <span class="op">!</span><span class="kw">is.na</span>(boston_<span class="dv">96</span><span class="op">$</span>median))</a>
<a class="sourceLine" id="cb548-3" title="3">lw_q_<span class="dv">94</span> &lt;-<span class="st"> </span>spdep<span class="op">::</span><span class="kw">nb2listw</span>(nb_q_<span class="dv">94</span>, <span class="dt">style=</span><span class="st">&quot;W&quot;</span>)</a></code></pre></div>
<p>We now have two data sets each at the lower, census tract level and the upper, air pollution model output zone level, one including the censored observations, the other excluding them.</p>
<p>The original model related the log of median house values by tract to the square of NOX values, including other covariates usually related to house value by tract, such as aggregate room counts, aggregate age, ethnicity, social status, distance to downtown and to the nearest radial road, a crime rate, and town-level variables reflecting land use (zoning, industry), taxation and education <span class="citation">(R. Bivand <a href="#ref-bivand17">2017</a>)</span>. This structure will be used here to exercise issues raised in fitting spatial regression models, including the presence of multiple levels.</p>
<div class="sourceCode" id="cb549"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb549-1" title="1">form &lt;-<span class="st"> </span><span class="kw">formula</span>(<span class="kw">log</span>(median) <span class="op">~</span><span class="st"> </span>CRIM <span class="op">+</span><span class="st"> </span>ZN <span class="op">+</span><span class="st"> </span>INDUS <span class="op">+</span><span class="st"> </span>CHAS <span class="op">+</span><span class="st"> </span><span class="kw">I</span>((NOX<span class="op">*</span><span class="dv">10</span>)<span class="op">^</span><span class="dv">2</span>) <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(RM<span class="op">^</span><span class="dv">2</span>) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb549-2" title="2"><span class="st">                  </span>AGE <span class="op">+</span><span class="st"> </span><span class="kw">log</span>(DIS) <span class="op">+</span><span class="st"> </span><span class="kw">log</span>(RAD) <span class="op">+</span><span class="st"> </span>TAX <span class="op">+</span><span class="st"> </span>PTRATIO <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(BB<span class="op">/</span><span class="dv">100</span>) <span class="op">+</span><span class="st"> </span></a>
<a class="sourceLine" id="cb549-3" title="3"><span class="st">                  </span><span class="kw">log</span>(<span class="kw">I</span>(LSTAT<span class="op">/</span><span class="dv">100</span>)))</a></code></pre></div>
<p>Before moving to presentations of issues raised in fitting spatial regression models, it is worth making a few further points. A recent review of spatial regression in a spatial econometrics setting is given by Kelejian and Piras <span class="citation">(<a href="#ref-kelejian+piras:17">2017</a>)</span>; note that their usage is to call the spatial coefficient of the lagged response <span class="math inline">\(\lambda\)</span> and that of the lagged residuals <span class="math inline">\(\rho\)</span>, the reverse of other usage <span class="citation">(Anselin <a href="#ref-a88">1988</a>; LeSage and Pace <a href="#ref-lesage+pace:09">2009</a>)</span>; here we use <span class="math inline">\(\rho_{\mathrm{Lag}}\)</span> for the spatial coefficient in the spatial lag model, and <span class="math inline">\(\rho_{\mathrm{Err}}\)</span> for the spatial error model. One interesting finding is that relatively dense spatial weights matrices may downweight model estimates, suggesting that sparser weights are preferable <span class="citation">(Smith <a href="#ref-smith:09">2009</a>)</span>. Another useful finding is that the presence of residual spatial autocorrelation need not bias the estimates of variance of regression coefficients, provided that the covariates themselves do not exhibit spatial autocorrelation <span class="citation">(Smith and Lee <a href="#ref-smith+lee12">2012</a>)</span>. In general, however, the footprints of the spatial processes of the response and covariates may not be aligned, and if covariates and the residual are autocorrelated, it is likely that the estimates of variance of regression coefficients will be biassed downwards if attempts are not made to model the spatial processes.</p>
<p>In trying to model these spatial processes, we may choose to model the spatial autocorrelation in the residual with a spatial error model (SEM).</p>
<p><span class="math display">\[
{\mathbf y} = {\mathbf X}{\mathbf \beta} + {\mathbf u},
\qquad {\mathbf u} = \rho_{\mathrm{Err}} {\mathbf W} {\mathbf u} + {\mathbf \varepsilon},
\]</span>
where <span class="math inline">\({\mathbf y}\)</span> is an <span class="math inline">\((N \times 1)\)</span> vector of observations on a response variable taken at each of <span class="math inline">\(N\)</span> locations, <span class="math inline">\({\mathbf X}\)</span> is an <span class="math inline">\((N \times k)\)</span> matrix of covariates, <span class="math inline">\({\mathbf \beta}\)</span> is a <span class="math inline">\((k \times 1)\)</span> vector of parameters, <span class="math inline">\({\mathbf u}\)</span> is an <span class="math inline">\((N \times 1)\)</span> spatially autocorrelated disturbance vector, <span class="math inline">\({\mathbf \varepsilon}\)</span> is an <span class="math inline">\((N \times 1)\)</span> vector of independent and identically distributed disturbances and <span class="math inline">\(\rho_{\mathrm{Err}}\)</span> is a scalar spatial parameter.</p>
<p>If the processes in the covariates and the response match, we should find little difference between the coefficients of a least squares and a SEM, but very often they diverge, suggesting that a Hausman test for this condition should be employed <span class="citation">(Pace and LeSage <a href="#ref-pace+lesage:08">2008</a>)</span>. This may be related to earlier discussions of a spatial equivalent to the unit root and cointegration where spatial processes match <span class="citation">(Fingleton <a href="#ref-fingleton:99">1999</a>)</span>.</p>
<p>A model with a spatial process in the response only is termed a spatial lag model (SLM, often SAR - spatial autoregressive) <span class="citation">(LeSage and Pace <a href="#ref-lesage+pace:09">2009</a>)</span>.</p>
<p><span class="math display">\[
{\mathbf y} = \rho_{\mathrm{Lag}} {\mathbf W}{\mathbf y} + {\mathbf X}{\mathbf \beta} + {\mathbf \varepsilon},
\]</span>
where <span class="math inline">\(\rho_{\mathrm{Lag}}\)</span> is a scalar spatial parameter.</p>
<p>Work reviewed by Mur and Angulo <span class="citation">(<a href="#ref-mur+angulo:06">2006</a>)</span> on the Durbin model; the Durbin model adds the spatially lagged covariates to the covariates included in the spatial lag model, giving a spatial Durbin model (SDM) with different processes in the response and covariates:</p>
<p><span class="math display">\[
{\mathbf y} = \rho_{\mathrm{Lag}} {\mathbf W}{\mathbf y} + {\mathbf X}{\mathbf \beta} + {\mathbf W}{\mathbf X}{\mathbf \gamma} + {\mathbf \varepsilon},
\]</span>
where <span class="math inline">\({\mathbf \gamma}\)</span> is a <span class="math inline">\((k&#39; \times 1)\)</span> vector of parameters. <span class="math inline">\(k&#39;\)</span> defines the subset of the intercept and covariates, often <span class="math inline">\(k&#39; = k-1\)</span> when using row standardised spatial weights and omitting the spatially lagged intercept.</p>
<p>This permits the spatial processes to be viewed and tested for as a Common Factor <span class="citation">(Burridge <a href="#ref-burridge:81">1981</a>; Bivand <a href="#ref-bivand:84">1984</a>)</span>. The inclusion of spatially lagged covariates lets us check whether the same spatial process is manifest in the response and the covariates (SEM), whether they are different processes, or whether no process is detected. The Common Factor is present when <span class="math inline">\({\mathbf \gamma} = - \rho_{\mathrm{Lag}} {\mathbf \beta}\)</span>:</p>
<p><span class="math display">\[
{\mathbf y} = \rho_{\mathrm{Lag}} {\mathbf W}{\mathbf y} + {\mathbf X}{\mathbf \beta} - \rho_{\mathrm{Lag}} {\mathbf W}{\mathbf X} {\mathbf \beta} + {\mathbf \varepsilon},
\qquad ({\mathbf I} - \rho_{\mathrm{Lag}} {\mathbf W}){\mathbf y} = ({\mathbf I} - \rho_{\mathrm{Lag}} {\mathbf W}) {\mathbf X}{\mathbf \beta} + {\mathbf \varepsilon},
\]</span>
where <span class="math inline">\({\mathbf I}\)</span> is the <span class="math inline">\(N \times N\)</span> identity matrix, and <span class="math inline">\({\mathbf I} - \rho_{\mathrm{Lag}} {\mathbf W}\)</span> is the Common Factor:</p>
<p><span class="math display">\[
\qquad {\mathbf y} = {\mathbf X}{\mathbf \beta} + ({\mathbf I} - \rho_{\mathrm{Lag}} {\mathbf W})^{-1} {\mathbf \varepsilon},
\qquad {\mathbf y} = {\mathbf X}{\mathbf \beta} + {\mathbf u},
\qquad {\mathbf u} = \rho_{\mathrm{Err}} {\mathbf W} {\mathbf u} + {\mathbf \varepsilon},
\]</span></p>
<p>If we extend this family with processes in the covariates and the residual, we get a spatial error Durbin model (SDEM). If it is chosen to admit a spatial process in the residuals in addition to a spatial process in the response, again two models are formed, a general nested model (GNM) nesting all the others, and a model without spatially lagged covariates (SAC, also known as SARAR - Spatial AutoRegressive-AutoRegressive model). If neither the residuals nor the residual are modelled with spatial processes, spatially lagged covariates may be added to a linear model, as a spatially lagged X model (SLX) <span class="citation">(Elhorst <a href="#ref-elhorst:10">2010</a>; Bivand <a href="#ref-bivand:12">2012</a>; LeSage <a href="#ref-lesage:14">2014</a>; Halleck Vega and Elhorst <a href="#ref-halleck-vega+elhorst:15">2015</a>)</span>.</p>
<p>We can write the general nested model (GNM) as:</p>
<p><span class="math display">\[
{\mathbf y} = \rho_{\mathrm{Lag}} {\mathbf W}{\mathbf y} + {\mathbf X}{\mathbf \beta} + {\mathbf W}{\mathbf X}{\mathbf \gamma} + {\mathbf u},
\qquad {\mathbf u} = \rho_{\mathrm{Err}} {\mathbf W} {\mathbf u} + {\mathbf \varepsilon},
\]</span></p>
<p>This may be constrained to the double spatial coefficient model SAC/SARAR by setting <span class="math inline">\({\mathbf \gamma} = 0\)</span>, to the spatial Durbin (SDM) by setting <span class="math inline">\(\rho_{\mathrm{Err}} = 0\)</span>, and to the error Durbin model (SDEM) by setting <span class="math inline">\(\rho_{\mathrm{Lag}} = 0\)</span>. Imposing more conditions gives the spatial lag model (SLM) with <span class="math inline">\({\mathbf \gamma} = 0\)</span> and <span class="math inline">\(\rho_{\mathrm{Err}} = 0\)</span>, the spatial error model (SEM) with <span class="math inline">\({\mathbf \gamma} = 0\)</span> and <span class="math inline">\(\rho_{\mathrm{Lag}} = 0\)</span>, and the spatially lagged X model (SLX) with <span class="math inline">\(\rho_{\mathrm{Lag}} = 0\)</span> and <span class="math inline">\(\rho_{\mathrm{Err}} = 0\)</span>.</p>
<p>Although making predictions for new locations for which covariates are observed was raised as an issue some time ago, it has many years to make progress in reviewing the possibilities <span class="citation">(Bivand <a href="#ref-bivand:02">2002</a>; Goulard, Laurent, and Thomas-Agnan <a href="#ref-goulardetal:17">2017</a>)</span>. The prediction methods for SLM, SDM, SEM, SDEM, SAC and GNM models fitted with maximum likelihood were contributed as a Google Summer of Coding project by Martin Gubri. This work, and work on similar models with missing data <span class="citation">(Suesse <a href="#ref-suesse:18">2018</a>)</span> is also relevant for exploring censored median house values in the Boston data set. Work on prediction also exposed the importance of the reduced form of these models, in which the spatial process in the response interacts with the regression coefficients in the SLM, SDM, SAC and GNM models.</p>
<p>The consequence of these interactions is that a unit change in a covariate will only impact the response as the value of the regression coefficient if the spatial coefficient of the lagged response is zero. Where it is non-zero, global spillovers, impacts, come into play, and these impacts should be reported rather than the regression coefficients <span class="citation">(LeSage and Pace <a href="#ref-lesage+pace:09">2009</a>; Elhorst <a href="#ref-elhorst:10">2010</a>; Bivand <a href="#ref-bivand:12">2012</a>; LeSage <a href="#ref-lesage:14">2014</a>; Halleck Vega and Elhorst <a href="#ref-halleck-vega+elhorst:15">2015</a>)</span>. Local impacts may be reported for SDEM and SLX models, using linear combination to calculate standard errors for the total impacts of each covariate (sums of coefficients on the covariates and their spatial lags).</p>
<p>This can be seen from the GNM data generation process:</p>
<p><span class="math display">\[
({\mathbf I} - \rho_{\mathrm{Err}} {\mathbf W})({\mathbf I} - \rho_{\mathrm{Lag}} {\mathbf W}){\mathbf y} = ({\mathbf I} - \rho_{\mathrm{Err}} {\mathbf W})({\mathbf X}{\mathbf \beta} + {\mathbf W}{\mathbf X}{\mathbf \gamma}) + {\mathbf \varepsilon},
\]</span>
re-writing:</p>
<p><span class="math display">\[
{\mathbf y} = ({\mathbf I} - \rho_{\mathrm{Lag}} {\mathbf W})^{-1}({\mathbf X}{\mathbf \beta} + {\mathbf W}{\mathbf X}{\mathbf \gamma}) + ({\mathbf I} - \rho_{\mathrm{Lag}} {\mathbf W})^{-1}({\mathbf I} - \rho_{\mathrm{Err}} {\mathbf W})^{-1}{\mathbf \varepsilon}.
\]</span>
There is interaction between the <span class="math inline">\(\rho_{\mathrm{Lag}}\)</span> and <span class="math inline">\({\mathbf \beta}\)</span> (and <span class="math inline">\({\mathbf \gamma}\)</span> if present) coefficients. This can be seen from the partial derivatives: <span class="math inline">\(\partial y_i / \partial x_{jr} = (({\mathbf I} - \rho_{\mathrm{Lag}} {\mathbf W})^{-1} ({\mathbf I} \beta_r + {\mathbf W} \gamma_r))_{ij}\)</span>. This dense matrix <span class="math inline">\(S_r({\mathbf W}) = (({\mathbf I} - \rho_{\mathrm{Lag}} {\mathbf W})^{-1} ({\mathbf I} \beta_r + {\mathbf W} \gamma_r))\)</span> expresses the direct impacts (effects) on its principal diagonal, and indirect impacts in off-diagonal elements.</p>
<p>Current work in the <strong>spatialreg</strong> package is focused on refining the handling of spatially lagged covariates using a consistent <code>Durbin=</code> argument taking either a logical value or a formula giving the subset of covariates to add in spatially lagged form. There is a speculation that some covariates, for example some dummy variables, should not be added in spatially lagged form. This then extends to handling these included spatially lagged covariates appropriately in calculating impacts. This work applies to cross-sectional models fitted using MCMC or maximum likelihood, and will offer facilities to spatial panel models.</p>
<p>It is worth mentioning the almost unexplored issues of functional form assumptions, for which flexible structures are useful, including spatial quantile regression presented in the <strong>McSpatial</strong> package <span class="citation">(McMillen <a href="#ref-mcmillen:13">2013</a>)</span>. There are further issues with discrete response variables, covered by some functions in <strong>McSpatial</strong>, and in the <strong>spatialprobit</strong> and <strong>ProbitSpatial</strong> packages <span class="citation">(Wilhelm and Matos <a href="#ref-RJ-2013-013">2013</a>; Martinetti and Geniaux <a href="#ref-MARTINETTI201730">2017</a>)</span>; the MCMC implementations of the former are based on LeSage and Pace <span class="citation">(<a href="#ref-lesage+pace:09">2009</a>)</span>. Finally, Wagner and Zeileis <span class="citation">(<a href="#ref-wagner+zeileis:19">2019</a>)</span> show how an SLM model may be used in the setting of recursive partitioning, with an implementation using <code>spatialreg::lagsarlm()</code> in the <strong>lagsarlmtree</strong> package.</p>
</div>
<div id="estimators" class="section level2">
<h2><span class="header-section-number">14.2</span> Estimators</h2>
<p>The review of cross-sectional maximum likelihood and generalized method of moments (GMM) estimators in <strong>spatialreg</strong> and <strong>sphet</strong> for spatial econometrics style spatial regression models by Bivand and Piras <span class="citation">(<a href="#ref-bivand+piras:15">2015</a>)</span> is still largely valid. In the review, estimators in these R packages were compared with alternative implementations available in other programming languages elsewhere. The review did not cover Bayesian spatial econometrics style spatial regression. More has changed with respect to spatial panel estimators described in Millo and Piras <span class="citation">(<a href="#ref-millo+piras:12">2012</a>)</span>, but will not be covered here.</p>
<div id="maximum-likelihood" class="section level3">
<h3><span class="header-section-number">14.2.1</span> Maximum likelihood</h3>
<p>For models with single spatial coefficients (SEM and SDEM using <code>errorsarlm()</code>, SLM and SDM using <code>lagsarlm()</code>), the methods initially described by Ord <span class="citation">(<a href="#ref-ord:75">1975</a>)</span> are used. The following table shows the functions that can be used to estimate the models described above using maximum likelihood.</p>
<table>
<thead>
<tr class="header">
<th>model</th>
<th>model name</th>
<th>maximum likelihood estimation function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SEM</td>
<td>spatial error</td>
<td><code>errorsarlm(..., Durbin=FALSE, ...)</code></td>
</tr>
<tr class="even">
<td>SEM</td>
<td>spatial error</td>
<td><code>spautolm(..., family="SAR", ...)</code></td>
</tr>
<tr class="odd">
<td>SDEM</td>
<td>spatial Durbin error</td>
<td><code>errorsarlm(..., Durbin=TRUE, ...)</code></td>
</tr>
<tr class="even">
<td>SLM</td>
<td>spatial lag</td>
<td><code>lagsarlm(..., Durbin=FALSE, ...)</code></td>
</tr>
<tr class="odd">
<td>SDM</td>
<td>spatial Durbin</td>
<td><code>lagsarlm(..., Durbin=TRUE, ...)</code></td>
</tr>
<tr class="even">
<td>SAC</td>
<td>spatial autoregressive combined</td>
<td><code>sacsarlm(..., Durbin=FALSE, ...)</code></td>
</tr>
<tr class="odd">
<td>GNM</td>
<td>general nested</td>
<td><code>sacsarlm(..., Durbin=TRUE, ...)</code></td>
</tr>
</tbody>
</table>
<p>The estimating functions <code>errorsarlm()</code> and <code>lagsarlm()</code> take similar arguments, where the first two, <code>formula=</code> and <code>data=</code> are shared by most model estimating functions. The third argument is a <code>listw</code> spatial weights object, while <code>na.action=</code> behaves as in other model estimating functions if the spatial weights can reasonably be subsetted to avoid observations with missing values. The <code>weights=</code> argument may be used to provide weights indicating the known degree of per-observation variability in the variance term - this is not available for <code>lagsarlm()</code>.</p>
<div class="sourceCode" id="cb550"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb550-1" title="1"><span class="kw">args</span>(errorsarlm)</a></code></pre></div>
<pre><code># function (formula, data = list(), listw, na.action, weights = NULL, 
#     Durbin, etype, method = &quot;eigen&quot;, quiet = NULL, zero.policy = NULL, 
#     interval = NULL, tol.solve = .Machine$double.eps, trs = NULL, 
#     control = list()) 
# NULL</code></pre>
<div class="sourceCode" id="cb552"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb552-1" title="1"><span class="kw">args</span>(lagsarlm)</a></code></pre></div>
<pre><code># function (formula, data = list(), listw, na.action, Durbin, type, 
#     method = &quot;eigen&quot;, quiet = NULL, zero.policy = NULL, interval = NULL, 
#     tol.solve = .Machine$double.eps, trs = NULL, control = list()) 
# NULL</code></pre>
<p>The <code>Durbin=</code> argument replaces the earlier <code>type=</code> and <code>etype=</code> arguments, and if not given is taken as <code>FALSE</code>. If given, it may be <code>FALSE</code>, <code>TRUE</code> in which case all spatially lagged covariates are included, or a one-sided formula specifying which spatially lagged covariates should be included. The <code>method=</code> argument gives the method for calculating the log determinant term in the log likelihood function, and defaults to <code>"eigen"</code>, suitable for moderately sized data sets. The <code>interval=</code> argument gives the bounds of the domain for the line search using <code>stats::optimize()</code> used for finding the spatial coefficient. The <code>tol.solve()</code> argument, passed through to <code>base::solve()</code>, was needed to handle data sets with differing numerical scales among the coefficients which hindered inversion of the variance-covariance matrix; the default value in <code>base::solve()</code> used to be much larger. The <code>control=</code> argument takes a list of control values to permit more careful adjustment of the running of the estimation function.</p>
<p>The <code>spautolm()</code> function also fits spatial regressions with the spatial process in the residuals, and takes a possibly poorly named <code>family=</code> argument, taking the values of <code>"SAR"</code> for the simultaneous autoregressive model (like <code>errorsarlm()</code>), <code>"CAR"</code> for the conditional autoregressive model, and <code>"SMA"</code> for the spatial moving average model.</p>
<div class="sourceCode" id="cb554"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb554-1" title="1"><span class="kw">args</span>(spautolm)</a></code></pre></div>
<pre><code># function (formula, data = list(), listw, weights, na.action, 
#     family = &quot;SAR&quot;, method = &quot;eigen&quot;, verbose = NULL, trs = NULL, 
#     interval = NULL, zero.policy = NULL, tol.solve = .Machine$double.eps, 
#     llprof = NULL, control = list()) 
# NULL</code></pre>
<p>The <code>sacsarlm()</code> function may take second spatial weights and interval arguments if the spatial weights used to model the two spatial processes in the SAC and GNM specifications differ. By default, the same spatial weights are used. By default, <code>stats::nlminb()</code> is used for numerical optimization, using a heuristic to choose starting values.</p>
<div class="sourceCode" id="cb556"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb556-1" title="1"><span class="kw">args</span>(sacsarlm)</a></code></pre></div>
<pre><code># function (formula, data = list(), listw, listw2 = NULL, na.action, 
#     Durbin, type, method = &quot;eigen&quot;, quiet = NULL, zero.policy = NULL, 
#     tol.solve = .Machine$double.eps, llprof = NULL, interval1 = NULL, 
#     interval2 = NULL, trs1 = NULL, trs2 = NULL, control = list()) 
# NULL</code></pre>
<p>Where larger data sets are used, a numerical Hessian approach is used to calculate the variance-covariance matrix of coefficients, rather than an analytical asymptotic approach.</p>
<p>Apart from <code>spautolm()</code> which returns an <code>"spautolm"</code> object, the model fitting functions return <code>"Sarlm"</code> objects. Standard methods for fitted models are provided, such as <code>summary()</code>:</p>
<div class="sourceCode" id="cb558"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb558-1" title="1"><span class="kw">args</span>(<span class="kw">getS3method</span>(<span class="st">&quot;summary&quot;</span>, <span class="st">&quot;Sarlm&quot;</span>))</a></code></pre></div>
<pre><code># function (object, correlation = FALSE, Nagelkerke = FALSE, Hausman = FALSE, 
#     adj.se = FALSE, ...) 
# NULL</code></pre>
<p>The <code>Nagelkerke=</code> argument permits the return of a value approximately corresponding to a coefficient of determination, although the summary method anyway provides the value of <code>stats::AIC()</code> because a <code>stats::logLik()</code> method is provided for <code>"sarlm"</code> and <code>"spautolm"</code> objects. If the <code>"sarlm"</code> object is a SEM or SDEM, the Hausman test may be performed by setting <code>Hausman=TRUE</code> to see whether the regression coefficients are sufficiently like least squares coefficients, indicating absence of mis-specification from that source. As an example, we may fit SEM and SDEM to the 94 and 489 observation Boston data sets, and present the Hausman test results:</p>
<div class="sourceCode" id="cb560"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb560-1" title="1">eigs_<span class="dv">489</span> &lt;-<span class="st"> </span><span class="kw">eigenw</span>(lw_q_<span class="dv">489</span>)</a>
<a class="sourceLine" id="cb560-2" title="2">SDEM_<span class="dv">489</span> &lt;-<span class="st"> </span><span class="kw">errorsarlm</span>(form, <span class="dt">data=</span>boston_<span class="dv">489</span>, <span class="dt">listw=</span>lw_q_<span class="dv">489</span>, <span class="dt">Durbin=</span><span class="ot">TRUE</span>, </a>
<a class="sourceLine" id="cb560-3" title="3">                       <span class="dt">zero.policy=</span><span class="ot">TRUE</span>, <span class="dt">control=</span><span class="kw">list</span>(<span class="dt">pre_eig=</span>eigs_<span class="dv">489</span>))</a>
<a class="sourceLine" id="cb560-4" title="4">SEM_<span class="dv">489</span> &lt;-<span class="st"> </span><span class="kw">errorsarlm</span>(form, <span class="dt">data=</span>boston_<span class="dv">489</span>, <span class="dt">listw=</span>lw_q_<span class="dv">489</span>, </a>
<a class="sourceLine" id="cb560-5" title="5">                      <span class="dt">zero.policy=</span><span class="ot">TRUE</span>, <span class="dt">control=</span><span class="kw">list</span>(<span class="dt">pre_eig=</span>eigs_<span class="dv">489</span>))</a>
<a class="sourceLine" id="cb560-6" title="6"><span class="kw">cbind</span>(<span class="kw">data.frame</span>(<span class="dt">model=</span><span class="kw">c</span>(<span class="st">&quot;SEM&quot;</span>, <span class="st">&quot;SDEM&quot;</span>)), </a>
<a class="sourceLine" id="cb560-7" title="7">      <span class="kw">rbind</span>(broom<span class="op">::</span><span class="kw">tidy</span>(<span class="kw">Hausman.test</span>(SEM_<span class="dv">489</span>)), </a>
<a class="sourceLine" id="cb560-8" title="8">            broom<span class="op">::</span><span class="kw">tidy</span>(<span class="kw">Hausman.test</span>(SDEM_<span class="dv">489</span>))))[,<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>]</a></code></pre></div>
<pre><code>#   model statistic  p.value parameter
# 1   SEM      52.0 2.83e-06        14
# 2  SDEM      48.7 6.48e-03        27</code></pre>
<p>Here we are using the <code>control=</code> list argument to pass through pre-computed eigenvalues for the default <code>"eigen"</code> method. Both test results for the 489 tract data set suggest that the regression coefficients do differ, perhaps that the footprints of the spatial processes do not match. Likelihood ratio tests of the spatial models against their least squares equivalents show that spatial process(es) are present, but we find that neither SEM not SDM are adequate representations.</p>
<div class="sourceCode" id="cb562"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb562-1" title="1"><span class="kw">cbind</span>(<span class="kw">data.frame</span>(<span class="dt">model=</span><span class="kw">c</span>(<span class="st">&quot;SEM&quot;</span>, <span class="st">&quot;SDEM&quot;</span>)), </a>
<a class="sourceLine" id="cb562-2" title="2">      <span class="kw">rbind</span>(broom<span class="op">::</span><span class="kw">tidy</span>(<span class="kw">LR1.Sarlm</span>(SEM_<span class="dv">489</span>)), </a>
<a class="sourceLine" id="cb562-3" title="3">            broom<span class="op">::</span><span class="kw">tidy</span>(<span class="kw">LR1.Sarlm</span>(SDEM_<span class="dv">489</span>))))[,<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">4</span><span class="op">:</span><span class="dv">6</span>)]</a></code></pre></div>
<pre><code>#   model statistic p.value parameter
# 1   SEM       198       0         1
# 2  SDEM       159       0         1</code></pre>
<p>For the 94 air pollution model output zones, the Hausman tests find little difference between coefficients, but this is related to the fact that the SEM and SDEM models add little to least squares or SLX using likelihood ratio tests.</p>
<div class="sourceCode" id="cb564"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb564-1" title="1">eigs_<span class="dv">94</span> &lt;-<span class="st"> </span><span class="kw">eigenw</span>(lw_q_<span class="dv">94</span>)</a>
<a class="sourceLine" id="cb564-2" title="2">SDEM_<span class="dv">94</span> &lt;-<span class="st"> </span><span class="kw">errorsarlm</span>(form, <span class="dt">data=</span>boston_<span class="dv">94</span>, <span class="dt">listw=</span>lw_q_<span class="dv">94</span>, <span class="dt">Durbin=</span><span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb564-3" title="3">                      <span class="dt">control=</span><span class="kw">list</span>(<span class="dt">pre_eig=</span>eigs_<span class="dv">94</span>))</a>
<a class="sourceLine" id="cb564-4" title="4">SEM_<span class="dv">94</span> &lt;-<span class="st"> </span><span class="kw">errorsarlm</span>(form, <span class="dt">data=</span>boston_<span class="dv">94</span>, <span class="dt">listw=</span>lw_q_<span class="dv">94</span>, <span class="dt">control=</span><span class="kw">list</span>(<span class="dt">pre_eig=</span>eigs_<span class="dv">94</span>))</a>
<a class="sourceLine" id="cb564-5" title="5"><span class="kw">cbind</span>(<span class="kw">data.frame</span>(<span class="dt">model=</span><span class="kw">c</span>(<span class="st">&quot;SEM&quot;</span>, <span class="st">&quot;SDEM&quot;</span>)), </a>
<a class="sourceLine" id="cb564-6" title="6">      <span class="kw">rbind</span>(broom<span class="op">::</span><span class="kw">tidy</span>(<span class="kw">Hausman.test</span>(SEM_<span class="dv">94</span>)), </a>
<a class="sourceLine" id="cb564-7" title="7">            broom<span class="op">::</span><span class="kw">tidy</span>(<span class="kw">Hausman.test</span>(SDEM_<span class="dv">94</span>))))[, <span class="dv">1</span><span class="op">:</span><span class="dv">4</span>]</a></code></pre></div>
<pre><code>#   model statistic p.value parameter
# 1   SEM     15.66   0.335        14
# 2  SDEM      9.21   0.999        27</code></pre>
<div class="sourceCode" id="cb566"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb566-1" title="1"><span class="kw">cbind</span>(<span class="kw">data.frame</span>(<span class="dt">model=</span><span class="kw">c</span>(<span class="st">&quot;SEM&quot;</span>, <span class="st">&quot;SDEM&quot;</span>)), <span class="kw">rbind</span>(broom<span class="op">::</span><span class="kw">tidy</span>(<span class="kw">LR1.Sarlm</span>(SEM_<span class="dv">94</span>)), broom<span class="op">::</span><span class="kw">tidy</span>(<span class="kw">LR1.Sarlm</span>(SDEM_<span class="dv">94</span>))))[,<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">4</span><span class="op">:</span><span class="dv">6</span>)]</a></code></pre></div>
<pre><code>#   model statistic p.value parameter
# 1   SEM     2.593   0.107         1
# 2  SDEM     0.216   0.642         1</code></pre>
<p>We can use <code>spatialreg::LR.sarlm()</code> to apply a likelihood ratio test between nested models, but here choose <code>lmtest::lrtest()</code>, which gives the same results, preferring models including spatially lagged covariates.</p>
<div class="sourceCode" id="cb568"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb568-1" title="1">broom<span class="op">::</span><span class="kw">tidy</span>(lmtest<span class="op">::</span><span class="kw">lrtest</span>(SEM_<span class="dv">489</span>, SDEM_<span class="dv">489</span>))</a></code></pre></div>
<pre><code># Warning in tidy.anova(lmtest::lrtest(SEM_489, SDEM_489)): The following column
# names in ANOVA output were not recognized or transformed: X.Df, LogLik</code></pre>
<pre><code># # A tibble: 2 x 5
#    X.Df LogLik    df statistic   p.value
#   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
# 1    16   273.    NA      NA   NA       
# 2    29   311.    13      74.4  1.23e-10</code></pre>
<div class="sourceCode" id="cb571"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb571-1" title="1">broom<span class="op">::</span><span class="kw">tidy</span>(lmtest<span class="op">::</span><span class="kw">lrtest</span>(SEM_<span class="dv">94</span>, SDEM_<span class="dv">94</span>))</a></code></pre></div>
<pre><code># Warning in tidy.anova(lmtest::lrtest(SEM_94, SDEM_94)): The following column
# names in ANOVA output were not recognized or transformed: X.Df, LogLik</code></pre>
<pre><code># # A tibble: 2 x 5
#    X.Df LogLik    df statistic    p.value
#   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
# 1    16   59.7    NA      NA   NA        
# 2    29   81.3    13      43.2  0.0000421</code></pre>
<p>The SLX model is fitted using least squares, and also returns a log likelihood value, letting us test whether we need a spatial process in the residuals.</p>
<div class="sourceCode" id="cb574"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb574-1" title="1"><span class="kw">args</span>(lmSLX)</a></code></pre></div>
<pre><code># function (formula, data = list(), listw, na.action, weights = NULL, 
#     Durbin = TRUE, zero.policy = NULL) 
# NULL</code></pre>
<p>In the tract data set we obviously do:</p>
<div class="sourceCode" id="cb576"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb576-1" title="1">SLX_<span class="dv">489</span> &lt;-<span class="st"> </span><span class="kw">lmSLX</span>(form, <span class="dt">data=</span>boston_<span class="dv">489</span>, <span class="dt">listw=</span>lw_q_<span class="dv">489</span>, <span class="dt">zero.policy=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb576-2" title="2">broom<span class="op">::</span><span class="kw">tidy</span>(lmtest<span class="op">::</span><span class="kw">lrtest</span>(SLX_<span class="dv">489</span>, SDEM_<span class="dv">489</span>))</a></code></pre></div>
<pre><code># Warning in modelUpdate(objects[[i - 1]], objects[[i]]): original model was of
# class &quot;SlX&quot;, updated model is of class &quot;Sarlm&quot;</code></pre>
<pre><code># Warning in tidy.anova(lmtest::lrtest(SLX_489, SDEM_489)): The following column
# names in ANOVA output were not recognized or transformed: X.Df, LogLik</code></pre>
<pre><code># # A tibble: 2 x 5
#    X.Df LogLik    df statistic   p.value
#   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
# 1    28   231.    NA       NA  NA       
# 2    29   311.     1      159.  1.55e-36</code></pre>
<p>but in the output zone case we do not.</p>
<div class="sourceCode" id="cb580"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb580-1" title="1">SLX_<span class="dv">94</span> &lt;-<span class="st"> </span><span class="kw">lmSLX</span>(form, <span class="dt">data=</span>boston_<span class="dv">94</span>, <span class="dt">listw=</span>lw_q_<span class="dv">94</span>)</a>
<a class="sourceLine" id="cb580-2" title="2">broom<span class="op">::</span><span class="kw">tidy</span>(lmtest<span class="op">::</span><span class="kw">lrtest</span>(SLX_<span class="dv">94</span>, SDEM_<span class="dv">94</span>))</a></code></pre></div>
<pre><code># Warning in modelUpdate(objects[[i - 1]], objects[[i]]): original model was of
# class &quot;SlX&quot;, updated model is of class &quot;Sarlm&quot;</code></pre>
<pre><code># Warning in tidy.anova(lmtest::lrtest(SLX_94, SDEM_94)): The following column
# names in ANOVA output were not recognized or transformed: X.Df, LogLik</code></pre>
<pre><code># # A tibble: 2 x 5
#    X.Df LogLik    df statistic p.value
#   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
# 1    28   81.2    NA    NA      NA    
# 2    29   81.3     1     0.216   0.642</code></pre>
<p>This outcome is sustained also when we use the counts of house units by tract and output zones as weights:</p>
<div class="sourceCode" id="cb584"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb584-1" title="1">SLX_94w &lt;-<span class="st"> </span><span class="kw">lmSLX</span>(form, <span class="dt">data=</span>boston_<span class="dv">94</span>, <span class="dt">listw=</span>lw_q_<span class="dv">94</span>, <span class="dt">weights=</span>units)</a>
<a class="sourceLine" id="cb584-2" title="2">SDEM_94w &lt;-<span class="st"> </span><span class="kw">errorsarlm</span>(form, <span class="dt">data=</span>boston_<span class="dv">94</span>, <span class="dt">listw=</span>lw_q_<span class="dv">94</span>, <span class="dt">Durbin=</span><span class="ot">TRUE</span>, <span class="dt">weights=</span>units,</a>
<a class="sourceLine" id="cb584-3" title="3">                       <span class="dt">control=</span><span class="kw">list</span>(<span class="dt">pre_eig=</span>eigs_<span class="dv">94</span>))</a>
<a class="sourceLine" id="cb584-4" title="4">broom<span class="op">::</span><span class="kw">tidy</span>(lmtest<span class="op">::</span><span class="kw">lrtest</span>(SLX_94w, SDEM_94w))</a></code></pre></div>
<pre><code># Warning in modelUpdate(objects[[i - 1]], objects[[i]]): original model was of
# class &quot;SlX&quot;, updated model is of class &quot;Sarlm&quot;</code></pre>
<pre><code># Warning in tidy.anova(lmtest::lrtest(SLX_94w, SDEM_94w)): The following column
# names in ANOVA output were not recognized or transformed: X.Df, LogLik</code></pre>
<pre><code># # A tibble: 2 x 5
#    X.Df LogLik    df statistic p.value
#   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
# 1    28   97.5    NA    NA      NA    
# 2    29   98.0     1     0.917   0.338</code></pre>
</div>
<div id="generalized-method-of-moments" class="section level3">
<h3><span class="header-section-number">14.2.2</span> Generalized method of moments</h3>
<p>The estimation methods used for fitting SLM and the spatially lagged response part of SARAR models are based on instrumental variables, using the spatially lagged covariates (usually including lags of lags too) as instruments for the spatially lagged response <span class="citation">(Piras <a href="#ref-piras:10">2010</a>)</span>. This, and the use of spatially lagged covariates in the moment conditions for models including a spatial process in the residuals, means that including the spatially lagged covariates in the initial model is challenging, and functions in the <strong>sphet</strong> package do not provide a <code>Durbin=</code> argument. This makes it harder to accommodate data with multiple spatial process footprints. However, as Kelejian and Piras show in their recent review <span class="citation">(<a href="#ref-kelejian+piras:17">2017</a>)</span>, these approaches have other benefits, such as being able to instrument variables suspected of suffering from endogeneity or measurement error.
Let us first compare the ML and GMM estimates of the SEM regression coefficients for rescaled squared NOX values. We use the <code>sphet::spreg()</code> wrapper function, and fit a SEM model. Extracting the matching rows from the summary objects for these models, we can see that the values are not dissimilar, despite the difference in estimation methods.</p>
<div class="sourceCode" id="cb588"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb588-1" title="1">SEM1_<span class="dv">94</span> &lt;-<span class="st"> </span>sphet<span class="op">::</span><span class="kw">spreg</span>(form, <span class="dt">data=</span>boston_<span class="dv">94</span>, <span class="dt">listw=</span>lw_q_<span class="dv">94</span>, <span class="dt">model=</span><span class="st">&quot;error&quot;</span>)</a>
<a class="sourceLine" id="cb588-2" title="2">res &lt;-<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">summary</span>(SEM_<span class="dv">94</span>)<span class="op">$</span>Coef[<span class="st">&quot;I((NOX * 10)^2)&quot;</span>,], </a>
<a class="sourceLine" id="cb588-3" title="3">             <span class="kw">summary</span>(SEM1_<span class="dv">94</span>)<span class="op">$</span>CoefTable[<span class="st">&quot;I((NOX * 10)^2)&quot;</span>,])</a>
<a class="sourceLine" id="cb588-4" title="4"><span class="kw">rownames</span>(res) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;ML&quot;</span>, <span class="st">&quot;GMM&quot;</span>)</a>
<a class="sourceLine" id="cb588-5" title="5">res</a></code></pre></div>
<pre><code>#     Estimate Std. Error z value Pr(&gt;|z|)
# ML  -0.00956    0.00261   -3.66 0.000247
# GMM -0.00885    0.00267   -3.31 0.000930</code></pre>
<p>Using <code>sphet::spreg()</code>, we can instrument the rescaled squared NOX variable, dropping it first from the formula, next creating the rescaled squared NOX variable as a column in the <code>"sf"</code> object, extracting a matrix of coordinates from the centroids of the output zones, and creating a one-sided instrument formula from a second order polynomial in the coordinates (here improperly, as they are not projected) and mean distances to downtown and radial roads. The <code>endog=</code> argument takes a one-sided formula for the variables to be modelled in the first stage of the model. Had we re-run the original air pollution model many times under slightly varying scenarios, we could have used an ensemble of NOX loadings to yield its distribution by output zone. Because this is not possible, we assume that the measurement error can be captured by using selected instruments. Unfortunately, the NOX regression coefficient estimate from the second stage has fallen substantially in absolute size, although the sign is unchanged.</p>
<div class="sourceCode" id="cb590"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb590-1" title="1">formiv &lt;-<span class="st"> </span><span class="kw">update</span>(form, . <span class="op">~</span><span class="st"> </span>. <span class="op">-</span><span class="st"> </span><span class="kw">I</span>((NOX<span class="op">*</span><span class="dv">10</span>)<span class="op">^</span><span class="dv">2</span>))</a>
<a class="sourceLine" id="cb590-2" title="2">boston_<span class="dv">94</span><span class="op">$</span>NOX2 &lt;-<span class="st"> </span>(boston_<span class="dv">94</span><span class="op">$</span>NOX<span class="op">*</span><span class="dv">10</span>)<span class="op">^</span><span class="dv">2</span></a>
<a class="sourceLine" id="cb590-3" title="3"><span class="kw">suppressWarnings</span>(ccoords &lt;-<span class="st"> </span><span class="kw">st_coordinates</span>(<span class="kw">st_centroid</span>(<span class="kw">st_geometry</span>(boston_<span class="dv">94</span>))))</a>
<a class="sourceLine" id="cb590-4" title="4">iform &lt;-<span class="st"> </span><span class="kw">formula</span>(<span class="op">~</span><span class="kw">poly</span>(ccoords, <span class="dt">degree=</span><span class="dv">2</span>) <span class="op">+</span><span class="st"> </span>DIS <span class="op">+</span><span class="st"> </span>RAD)</a>
<a class="sourceLine" id="cb590-5" title="5">SEM1_94iv &lt;-<span class="st"> </span>sphet<span class="op">::</span><span class="kw">spreg</span>(formiv, <span class="dt">data=</span>boston_<span class="dv">94</span>, <span class="dt">listw=</span>lw_q_<span class="dv">94</span>, <span class="dt">endog =</span> <span class="op">~</span>NOX2, </a>
<a class="sourceLine" id="cb590-6" title="6">                   <span class="dt">instruments=</span>iform, <span class="dt">model=</span><span class="st">&quot;error&quot;</span>)</a>
<a class="sourceLine" id="cb590-7" title="7"><span class="kw">summary</span>(SEM1_94iv)<span class="op">$</span>CoefTable[<span class="st">&quot;NOX2&quot;</span>,]</a></code></pre></div>
<pre><code>#   Estimate Std. Error    t-value   Pr(&gt;|t|) 
#   -0.00195    0.00454   -0.43063    0.66674</code></pre>
<p>Handling measurement error in this or similar ways is one of the benefits of GMM estimation methods, although here the choice of instruments was somewhat arbitrary.</p>
</div>
<div id="markov-chain-monte-carlo" class="section level3">
<h3><span class="header-section-number">14.2.3</span> Markov chain Monte Carlo</h3>
<p>(draft - a comparative piece is being written for submission in about two months)</p>
<p>The Spatial Econometrics Library is part of the extensive Matlab code repository at <a href="https://www.spatial-econometrics.com/" class="uri">https://www.spatial-econometrics.com/</a> and documented in LeSage and Pace <span class="citation">(<a href="#ref-lesage+pace:09">2009</a>)</span>. The Google Summer of Coding project in 2011 by Abhirup Mallik mentored by Virgilio Gómez-Rubio yielded translations of some of the model fitting functions for SEM, SDEM, SLM, SDM, SAC and GNM from the Matlab code. These have now been added to <strong>spatialreg</strong> as <code>spBreg_err()</code>, <code>spBreg_lag()</code> and <code>spBreg_sac()</code> with <code>Durbin=</code> arguments to handle the inclusion of spatially lagged covariates. As yet, heteroskedastic disturbances are not accommodated. The functions return <code>"mcmc"</code> objects as specified in the <strong>coda</strong> package, permitting the use of tools from <strong>coda</strong> for handling model output. The default burnin is 500 draws, followed by default 2000 draws returned, but these values and many others may be set through the <code>control=</code> list argument. Fitting the SDEM model for the output zones takes about an order of magnitude longer than using ML, but there is more work to do subsequently, and this difference scales more in the number of samples than covariates or observations.</p>
<div class="sourceCode" id="cb592"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb592-1" title="1"><span class="kw">system.time</span>(SDEM_94B &lt;-<span class="st"> </span><span class="kw">spBreg_err</span>(form, <span class="dt">data=</span>boston_<span class="dv">94</span>, <span class="dt">listw=</span>lw_q_<span class="dv">94</span>, <span class="dt">Durbin=</span><span class="ot">TRUE</span>))</a></code></pre></div>
<pre><code>#    user  system elapsed 
#    2.66    0.00    2.66</code></pre>
<div class="sourceCode" id="cb594"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb594-1" title="1"><span class="kw">system.time</span>(SDEM_489B &lt;-<span class="st"> </span><span class="kw">spBreg_err</span>(form, <span class="dt">data=</span>boston_<span class="dv">489</span>, <span class="dt">listw=</span>lw_q_<span class="dv">489</span>, <span class="dt">Durbin=</span><span class="ot">TRUE</span>, <span class="dt">zero.policy=</span><span class="ot">TRUE</span>))</a></code></pre></div>
<pre><code>#    user  system elapsed 
#     3.7     0.0     3.7</code></pre>
<p>Most time in the ML case using eigenvalues is taken by log determinant setup and optimization, and by dense matrix asymptotic standard errors if chosen (always chosen with default <code>"eigen"</code> log determinant method):</p>
<div class="sourceCode" id="cb596"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb596-1" title="1"><span class="kw">t</span>(<span class="kw">errorsarlm</span>(form, <span class="dt">data=</span>boston_<span class="dv">94</span>, <span class="dt">listw=</span>lw_q_<span class="dv">94</span>, <span class="dt">Durbin=</span><span class="ot">TRUE</span>)<span class="op">$</span>timings[,<span class="dv">2</span>])</a></code></pre></div>
<pre><code>#      set_up eigen_set_up eigen_opt coefs eigen_hcov eigen_se
# [1,]  0.006        0.008     0.011 0.006      0.003    0.002</code></pre>
<div class="sourceCode" id="cb598"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb598-1" title="1"><span class="kw">t</span>(<span class="kw">errorsarlm</span>(form, <span class="dt">data=</span>boston_<span class="dv">489</span>, <span class="dt">listw=</span>lw_q_<span class="dv">489</span>, <span class="dt">Durbin=</span><span class="ot">TRUE</span>, <span class="dt">zero.policy=</span><span class="ot">TRUE</span>)<span class="op">$</span>timings[,<span class="dv">2</span>])</a></code></pre></div>
<pre><code>#      set_up eigen_set_up eigen_opt coefs eigen_hcov eigen_se
# [1,]  0.014        0.075     0.031 0.007      0.115    0.234</code></pre>
<p>while in the MCMC case, the default use of Spatial Econometric Toolbox gridded log determinants and obviously sampling takes most time:</p>
<div class="sourceCode" id="cb600"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb600-1" title="1"><span class="kw">t</span>(<span class="kw">attr</span>(SDEM_94B, <span class="st">&quot;timings&quot;</span>)[ , <span class="dv">3</span>])</a></code></pre></div>
<pre><code>#      set_up SE_classic_set_up complete_setup sampling finalise
# [1,]  0.005             0.361          0.041     2.18    0.074</code></pre>
<div class="sourceCode" id="cb602"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb602-1" title="1"><span class="kw">t</span>(<span class="kw">attr</span>(SDEM_489B, <span class="st">&quot;timings&quot;</span>)[ , <span class="dv">3</span>])</a></code></pre></div>
<pre><code>#      set_up SE_classic_set_up complete_setup sampling finalise
# [1,]  0.008             0.591          0.099     2.92    0.076</code></pre>
<p>However, as we will see shortly, inference from model impacts may need sampling (where the spatially lagged response is included in the model), and in the case of MCMC models, the samples have already been drawn.</p>
</div>
</div>
<div id="implementation-details" class="section level2">
<h2><span class="header-section-number">14.3</span> Implementation details</h2>
<p>We will briefly touch on selected implementation details that applied users of spatial regression models would be wise to review. The handling of the log determinant term applies to all such users, while impacts are restricted to those employing spatial econometrics style models either including the spatially lagged response or including spatially lagged covariates.</p>
<div id="handling-the-log-determinant-term" class="section level3">
<h3><span class="header-section-number">14.3.1</span> Handling the log determinant term</h3>
<p>It has been known for over twenty years that the sparse matrix representation of spatial weights overcomes the difficulties of fitting models with larger numbers of observations using maximum likelihood and MCMC where the log determinant term comes into play <span class="citation">(R. K. Pace and Barry <a href="#ref-pace+barry:97a">1997</a><a href="#ref-pace+barry:97a">a</a>, <a href="#ref-pace+barry:97b">1997</a><a href="#ref-pace+barry:97b">c</a>, <a href="#ref-pace+barry:97c">1997</a><a href="#ref-pace+barry:97c">d</a>, <a href="#ref-pace+barry:97d">1997</a><a href="#ref-pace+barry:97d">b</a>)</span>. During the development of these approaches in model fitting functions in <strong>spatialreg</strong>, use was first made of C code also used in the S-PLUS SpatialStats module <span class="citation">(Kaluzny et al. <a href="#ref-kaluznyetal:98">1998</a>)</span>, then <strong>SparseM</strong> which used a compressed sparse row form very similar to <code>"nb"</code> and <code>"listw"</code> objects. This was followed by the use of <strong>spam</strong> and <strong>Matrix</strong> methods, both of which mainly use compressed sparse column representations. Details are provided in Bivand, Hauke and Kossowski <span class="citation">(<a href="#ref-bivandetal13">2013</a>)</span>.</p>
<p>The domain of the spatial coefficient(s) is given by the <code>interval=</code> argument to model fitting functions, and returned in the fitted object:</p>
<div class="sourceCode" id="cb604"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb604-1" title="1">SEM_<span class="dv">94</span><span class="op">$</span>interval</a></code></pre></div>
<pre><code># [1] -1.53  1.00</code></pre>
<p>This case is trivial, because the upper bound is unity by definition, because of the use of row standardization. The interval is the inverse of the range of the eigenvalues of the weights matrix:</p>
<div class="sourceCode" id="cb606"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb606-1" title="1"><span class="dv">1</span><span class="op">/</span><span class="kw">range</span>(eigs_<span class="dv">94</span>)</a></code></pre></div>
<pre><code># [1] -1.53  1.00</code></pre>
<p>Finding the interval within which to search for the spatial coefficient is trivial for smaller data sets, but more complex for larger ones. It is possible to use heuristics implemented in <code>lextrW()</code> <span class="citation">(Griffith, Bivand, and Chun <a href="#ref-GRIFFITH2015119">2015</a>)</span>:</p>
<div class="sourceCode" id="cb608"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb608-1" title="1"><span class="dv">1</span><span class="op">/</span><span class="kw">c</span>(<span class="kw">lextrW</span>(lw_q_<span class="dv">94</span>))</a></code></pre></div>
<pre><code># lambda_n lambda_1 
#    -1.53     1.00</code></pre>
<p>or <code>RSpectra::eigs()</code> after coercion to a <strong>Matrix</strong> package compressed sparse column representation:</p>
<div class="sourceCode" id="cb610"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb610-1" title="1">W &lt;-<span class="st"> </span><span class="kw">as</span>(lw_q_<span class="dv">94</span>, <span class="st">&quot;CsparseMatrix&quot;</span>)</a>
<a class="sourceLine" id="cb610-2" title="2"><span class="dv">1</span><span class="op">/</span><span class="kw">Re</span>(<span class="kw">c</span>(RSpectra<span class="op">::</span><span class="kw">eigs</span>(W, <span class="dt">k=</span><span class="dv">1</span>, <span class="dt">which=</span><span class="st">&quot;SR&quot;</span>)<span class="op">$</span>values, </a>
<a class="sourceLine" id="cb610-3" title="3">       RSpectra<span class="op">::</span><span class="kw">eigs</span>(W, <span class="dt">k=</span><span class="dv">1</span>, <span class="dt">which=</span><span class="st">&quot;LR&quot;</span>)<span class="op">$</span>values))</a></code></pre></div>
<pre><code># [1] -1.53  1.00</code></pre>
<p>Why are we extracting the real part of the values returned by <code>eigs()</code>? Since <code>nb_q_94</code> is symmetric, the row-standardized object <code>lw_q_94</code> is symmetric by similarity, a result known since Ord <span class="citation">(<a href="#ref-ord:75">1975</a>)</span>; consequently, we can take the real part without concern. Had the underlying neighbour relationships not been symmetric, we should be more careful.</p>
<p>The baseline log determinant term as given by Ord <span class="citation">(<a href="#ref-ord:75">1975</a>)</span> for a coefficient value proposed in sampling or during numerical optimization; this extract matches the <code>"eigen"</code> method (with or without <code>control=list(pre_eig=...)"</code>):</p>
<div class="sourceCode" id="cb612"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb612-1" title="1">coef &lt;-<span class="st"> </span><span class="fl">0.5</span></a>
<a class="sourceLine" id="cb612-2" title="2"><span class="kw">sum</span>(<span class="kw">log</span>(<span class="dv">1</span> <span class="op">-</span><span class="st"> </span>coef <span class="op">*</span><span class="st"> </span>eigs_<span class="dv">94</span>))</a></code></pre></div>
<pre><code># [1] -2.87</code></pre>
<p>Using sparse matrix functions from <strong>Matrix</strong>, the LU decomposition can be used for asymmetric matrices; this extract matches the <code>"LU"</code> method:</p>
<div class="sourceCode" id="cb614"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb614-1" title="1">I &lt;-<span class="st"> </span><span class="kw">Diagonal</span>(<span class="kw">nrow</span>(boston_<span class="dv">94</span>))</a>
<a class="sourceLine" id="cb614-2" title="2">LU &lt;-<span class="st"> </span><span class="kw">lu</span>(I <span class="op">-</span><span class="st"> </span>coef <span class="op">*</span><span class="st"> </span>W)</a>
<a class="sourceLine" id="cb614-3" title="3">dU &lt;-<span class="st"> </span><span class="kw">abs</span>(<span class="kw">diag</span>(<span class="kw">slot</span>(LU, <span class="st">&quot;U&quot;</span>)))</a>
<a class="sourceLine" id="cb614-4" title="4"><span class="kw">sum</span>(<span class="kw">log</span>(dU))</a></code></pre></div>
<pre><code># [1] -2.87</code></pre>
<p>and Cholesky decomposition for symmetric matrices, with <code>similar.listw()</code> used to handle asymmetric weights that are similar to symmetric. The default value od <code>super</code> allows the underlying <strong>Matrix</strong> code to choose between supernodal or simplicial decomposition; this extract matches the <code>"Matrix_J"</code> method:</p>
<div class="sourceCode" id="cb616"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb616-1" title="1">W &lt;-<span class="st"> </span><span class="kw">as</span>(<span class="kw">similar.listw</span>(lw_q_<span class="dv">94</span>), <span class="st">&quot;CsparseMatrix&quot;</span>)</a>
<a class="sourceLine" id="cb616-2" title="2">super &lt;-<span class="st"> </span><span class="kw">as.logical</span>(<span class="ot">NA</span>)</a>
<a class="sourceLine" id="cb616-3" title="3">cch &lt;-<span class="st"> </span><span class="kw">Cholesky</span>((I <span class="op">-</span><span class="st"> </span>coef <span class="op">*</span><span class="st"> </span>W), <span class="dt">super=</span>super)</a>
<a class="sourceLine" id="cb616-4" title="4"><span class="kw">c</span>(<span class="dv">2</span> <span class="op">*</span><span class="st"> </span><span class="kw">determinant</span>(cch, <span class="dt">logarithm =</span> <span class="ot">TRUE</span>)<span class="op">$</span>modulus)</a></code></pre></div>
<pre><code># [1] -2.87</code></pre>
<p>The <code>"Matrix"</code> and <code>"spam_update"</code> methods are to be preferred as they pre-compute the fill-reducing permutation of the decomposition since the weights do not change for different values of the coefficient.</p>
<p>Maximum likelihood model fitting functions in <strong>spatialreg</strong> and <strong>splm</strong> use <code>jacobianSetup()</code> to populate <code>env=</code> environment with intermediate objects needed to find log determinants during optimization. Passing environments to objective functions is efficient because they are passed by reference rather than value. The <code>con=</code> argument passes through the populated control list, containing default values unless the key-value pairs were given in the function call (<code>pre_eig=</code> is extracted separately). The <code>which=</code> argument is <code>1</code> by default, but will also take <code>2</code> in SAC and GNM models. <strong>HSAR</strong> uses <code>mcdet_setup()</code> to set up Monte Carlo approximation terms.</p>
<div class="sourceCode" id="cb618"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb618-1" title="1"><span class="kw">args</span>(jacobianSetup)</a></code></pre></div>
<pre><code># function (method, env, con, pre_eig = NULL, trs = NULL, interval = NULL, 
#     which = 1) 
# NULL</code></pre>
<p>For each value of <code>coef</code>, the <code>do_ldet()</code> function returns the log determinant, using the values stored in environment <code>env=</code>:</p>
<div class="sourceCode" id="cb620"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb620-1" title="1"><span class="kw">args</span>(do_ldet)</a></code></pre></div>
<pre><code># function (coef, env, which = 1) 
# NULL</code></pre>
<p>As yet the Bayesian models are limited to control argument <code>ldet_method="SE_classic"</code> at present, using <code>"LU"</code> to generate a coarse grid of control argument <code>nrho=200L</code> log determinant values in the interval, spline interpolated to a finer grid of length control argument <code>interpn=2000L</code>, from which griddy Gibbs samples are drawn. It is hoped to add facilities to choose alternative methods in the future. This would offer possibilities to move beyond griddy Gibbs, but using gridded log determinant values seems reasonable at present.</p>
</div>
<div id="impacts" class="section level3">
<h3><span class="header-section-number">14.3.2</span> Impacts</h3>
<p>Global impacts have been seen as crucial for reporting results from fitting models including the spatially lagged response (SLM, SDM, SAC. GNM) for over ten years <span class="citation">(LeSage and Pace <a href="#ref-lesage+pace:09">2009</a>)</span>. Extension to other models including spatially lagged covariates (SLX, SDEM) has followed <span class="citation">(Elhorst <a href="#ref-elhorst:10">2010</a>; Bivand <a href="#ref-bivand:12">2012</a>; Halleck Vega and Elhorst <a href="#ref-halleck-vega+elhorst:15">2015</a>)</span>. In order to infer from the impacts, linear combination may be used for SLX and SDEM models. For SLM, SDM, SAC and GNM models fitted with maximum likelihood or GMM, the variance-covariance matrix of the coefficients is available, and can be used to make random draws from a multivariate Normal distribution with mean set to coefficient values and variance to the estimated variance-covariance matrix. For these models fitted using Bayesian methods, draws are already available. In the SDEM case, the draws on the regression coefficients of the unlagged covariates represent direct impacts, and draws on the coefficients of the spatially lagged covariates represent indirect impacts, and their by-draw sums the total impacts.</p>
<p>Impacts are calculated using model object class specific <code>impacts()</code> methods, here taking the method for <code>"sarlm"</code> objects as an example. In the <strong>sphet</strong> package, the impacts method for <code>"gstsls"</code> uses the <strong>spatialreg</strong> <code>impacts()</code> framework, as does the <strong>splm</strong> package for <code>"splm"</code> fitted model objects. <code>impacts()</code> methods require either a <code>tr=</code> - a vector of traces of the power series of the weights object typically computed with <code>trW()</code> or a <code>listw=</code> argument. If <code>listw=</code> is given, dense matrix methods are used. The <code>evalues=</code> argument is experimental, does not yet work for all model types, and takes the eigenvalues of the weights matrix. The <code>R=</code> argument gives the number of samples to be taken from the fitted model. The <code>Q=</code> permits the decomposition of impacts to components of the power series of the weights matrix <span class="citation">(LeSage and Pace <a href="#ref-lesage+pace:09">2009</a>)</span>.</p>
<div class="sourceCode" id="cb622"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb622-1" title="1"><span class="kw">args</span>(<span class="kw">getS3method</span>(<span class="st">&quot;impacts&quot;</span>, <span class="st">&quot;Sarlm&quot;</span>))</a></code></pre></div>
<pre><code># function (obj, ..., tr = NULL, R = NULL, listw = NULL, evalues = NULL, 
#     useHESS = NULL, tol = 1e-06, empirical = FALSE, Q = NULL) 
# NULL</code></pre>
<p>The summary method for the output of <code>impacts()</code> methods where inference from samples was requested by default uses the <code>summary()</code> method for <code>"mcmc"</code> objects defined in the <strong>coda</strong> package. It can instead report just matrices of standard errors, z-values and p-values by setting <code>zstats=</code> and <code>short=</code> to <code>TRUE</code>.</p>
<div class="sourceCode" id="cb624"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb624-1" title="1"><span class="kw">args</span>(<span class="kw">getS3method</span>(<span class="st">&quot;summary&quot;</span>, <span class="st">&quot;LagImpact&quot;</span>))</a></code></pre></div>
<pre><code># function (object, ..., zstats = FALSE, short = FALSE, reportQ = NULL) 
# NULL</code></pre>
<p>Since sampling is not required for inference for SLX and SDEM models, linear combination is used for models fitted using maximum likelihood; results are shown here for the air pollution variable only. The literature has not yet resolved the question of how to report model output, as each covariate is now represented by three impacts. Where spatially lagged covariates are included, two coefficients are replaced by three impacts.</p>
<div class="sourceCode" id="cb626"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb626-1" title="1">sum_imp_<span class="dv">94</span>_SDEM &lt;-<span class="st"> </span><span class="kw">summary</span>(<span class="kw">impacts</span>(SDEM_<span class="dv">94</span>))</a>
<a class="sourceLine" id="cb626-2" title="2"><span class="kw">rbind</span>(<span class="dt">Impacts=</span>sum_imp_<span class="dv">94</span>_SDEM<span class="op">$</span>mat[<span class="dv">5</span>,], <span class="dt">SE=</span>sum_imp_<span class="dv">94</span>_SDEM<span class="op">$</span>semat[<span class="dv">5</span>,])</a></code></pre></div>
<pre><code>#           Direct Indirect   Total
# Impacts -0.01276 -0.01845 -0.0312
# SE       0.00235  0.00472  0.0053</code></pre>
<p>The impacts from the same model fitted by MCMC are very similar:</p>
<div class="sourceCode" id="cb628"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb628-1" title="1">sum_imp_<span class="dv">94</span>_SDEM_B &lt;-<span class="st"> </span><span class="kw">summary</span>(<span class="kw">impacts</span>(SDEM_94B))</a>
<a class="sourceLine" id="cb628-2" title="2"><span class="kw">rbind</span>(<span class="dt">Impacts=</span>sum_imp_<span class="dv">94</span>_SDEM_B<span class="op">$</span>mat[<span class="dv">5</span>,], <span class="dt">SE=</span>sum_imp_<span class="dv">94</span>_SDEM_B<span class="op">$</span>semat[<span class="dv">5</span>,])</a></code></pre></div>
<pre><code>#           Direct Indirect    Total
# Impacts -0.01276 -0.01768 -0.03044
# SE       0.00266  0.00567  0.00692</code></pre>
<p>as also are those from the SLX model. In the SLX and SDEM models, the direct impacts are the consequences for the response of changes in air pollution in the same observational entity, and the indirect (local) impacts are the consequences for the response of changes in air pollution in neighbouring observational entities.</p>
<div class="sourceCode" id="cb630"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb630-1" title="1">sum_imp_<span class="dv">94</span>_SLX &lt;-<span class="st"> </span><span class="kw">summary</span>(<span class="kw">impacts</span>(SLX_<span class="dv">94</span>))</a>
<a class="sourceLine" id="cb630-2" title="2"><span class="kw">rbind</span>(<span class="dt">Impacts=</span>sum_imp_<span class="dv">94</span>_SLX<span class="op">$</span>mat[<span class="dv">5</span>,], <span class="dt">SE=</span>sum_imp_<span class="dv">94</span>_SLX<span class="op">$</span>semat[<span class="dv">5</span>,])</a></code></pre></div>
<pre><code>#          Direct Indirect    Total
# Impacts -0.0128 -0.01874 -0.03151
# SE       0.0028  0.00556  0.00611</code></pre>
<p>In contrast to local indirect impacts in SLX and SDEM models, global indirect impacts are found in models including the spatially lagged response. For purposes of exposition, let us fit an SLM:</p>
<div class="sourceCode" id="cb632"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb632-1" title="1">SLM_<span class="dv">489</span> &lt;-<span class="st"> </span><span class="kw">lagsarlm</span>(form, <span class="dt">data=</span>boston_<span class="dv">489</span>, <span class="dt">listw=</span>lw_q_<span class="dv">489</span>, <span class="dt">zero.policy=</span><span class="ot">TRUE</span>)</a></code></pre></div>
<p>Traces of the first <code>m=</code> matrices of the power series in the spatial weights are pre-computed to speed up inference from samples from the fitted model, and from existing MCMC samples <span class="citation">(LeSage and Pace <a href="#ref-lesage+pace:09">2009</a>)</span>. The traces can also be used in other contexts too, so their pre-computation may be worthwhile anyway. The <code>type=</code> argument is <code>"mult"</code> by default, but may also be set to <code>"MC"</code> for Monte Carlo simulation or <code>"moments"</code> using a space-saving looping algorithm.</p>
<div class="sourceCode" id="cb633"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb633-1" title="1"><span class="kw">args</span>(trW)</a></code></pre></div>
<pre><code># function (W = NULL, m = 30, p = 16, type = &quot;mult&quot;, listw = NULL, 
#     momentsSymmetry = TRUE) 
# NULL</code></pre>
<div class="sourceCode" id="cb635"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb635-1" title="1">W &lt;-<span class="st"> </span><span class="kw">as</span>(lw_q_<span class="dv">489</span>, <span class="st">&quot;CsparseMatrix&quot;</span>)</a>
<a class="sourceLine" id="cb635-2" title="2">tr_<span class="dv">489</span> &lt;-<span class="st"> </span><span class="kw">trW</span>(W)</a>
<a class="sourceLine" id="cb635-3" title="3"><span class="kw">str</span>(tr_<span class="dv">489</span>)</a></code></pre></div>
<pre><code>#  num [1:30] 0 90.8 29.4 42.1 26.5 ...
#  - attr(*, &quot;timings&quot;)= Named num [1:2] 0.156 0.156
#   ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;user.self&quot; &quot;elapsed&quot;
#  - attr(*, &quot;type&quot;)= chr &quot;mult&quot;
#  - attr(*, &quot;n&quot;)= int 489</code></pre>
<p>In this case, the spatial process in the response is not strong, so the global indirect impacts (here for the air pollution variable) are weak.</p>
<div class="sourceCode" id="cb637"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb637-1" title="1">SLM_<span class="dv">489</span>_imp &lt;-<span class="st"> </span><span class="kw">impacts</span>(SLM_<span class="dv">489</span>, <span class="dt">tr=</span>tr_<span class="dv">489</span>, <span class="dt">R=</span><span class="dv">2000</span>)</a>
<a class="sourceLine" id="cb637-2" title="2">SLM_<span class="dv">489</span>_imp_sum &lt;-<span class="st"> </span><span class="kw">summary</span>(SLM_<span class="dv">489</span>_imp, <span class="dt">short=</span><span class="ot">TRUE</span>, <span class="dt">zstats=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb637-3" title="3">res &lt;-<span class="st"> </span><span class="kw">rbind</span>(<span class="dt">Impacts=</span><span class="kw">sapply</span>(SLM_<span class="dv">489</span>_imp<span class="op">$</span>res, <span class="st">&quot;[&quot;</span>, <span class="dv">5</span>), <span class="dt">SE=</span>SLM_<span class="dv">489</span>_imp_sum<span class="op">$</span>semat[<span class="dv">5</span>,])</a>
<a class="sourceLine" id="cb637-4" title="4"><span class="kw">colnames</span>(res) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Direct&quot;</span>, <span class="st">&quot;Indirect&quot;</span>, <span class="st">&quot;Total&quot;</span>)</a>
<a class="sourceLine" id="cb637-5" title="5">res</a></code></pre></div>
<pre><code>#           Direct  Indirect    Total
# Impacts -0.00593 -1.01e-05 -0.00594
# SE       0.00106  1.00e-04  0.00107</code></pre>
<p>Of more interest is trying to reconstruct the direct and total impacts using dense matrix methods; the direct global impacts are the mean of the diagonal of the dense impacts matrix, and the total global impacts are the sum of all matrix elements divided by the number of observations. The direct impacts agree, but the total impacts differ slightly.</p>
<div class="sourceCode" id="cb639"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb639-1" title="1">coef_SLM_<span class="dv">489</span> &lt;-<span class="st"> </span><span class="kw">coef</span>(SLM_<span class="dv">489</span>)</a>
<a class="sourceLine" id="cb639-2" title="2">IrW &lt;-<span class="st"> </span><span class="kw">Diagonal</span>(<span class="dv">489</span>) <span class="op">-</span><span class="st"> </span>coef_SLM_<span class="dv">489</span>[<span class="dv">1</span>] <span class="op">*</span><span class="st"> </span>W</a>
<a class="sourceLine" id="cb639-3" title="3">S_W &lt;-<span class="st"> </span><span class="kw">solve</span>(IrW)</a>
<a class="sourceLine" id="cb639-4" title="4">S_NOX_W &lt;-<span class="st"> </span>S_W <span class="op">%*%</span><span class="st"> </span>(<span class="kw">diag</span>(<span class="dv">489</span>) <span class="op">*</span><span class="st"> </span>coef_SLM_<span class="dv">489</span>[<span class="dv">7</span>])</a>
<a class="sourceLine" id="cb639-5" title="5"><span class="kw">c</span>(<span class="dt">Direct=</span><span class="kw">mean</span>(<span class="kw">diag</span>(S_NOX_W)), <span class="dt">Total=</span><span class="kw">sum</span>(S_NOX_W)<span class="op">/</span><span class="dv">489</span>)</a></code></pre></div>
<pre><code>#   Direct    Total 
# -0.00593 -0.00594</code></pre>
<p>This bare-bones approach corresponds to using the <code>listw=</code> argument, and as expected gives the same output.</p>
<div class="sourceCode" id="cb641"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb641-1" title="1"><span class="kw">sapply</span>(<span class="kw">impacts</span>(SLM_<span class="dv">489</span>, <span class="dt">listw=</span>lw_q_<span class="dv">489</span>), <span class="st">&quot;[&quot;</span>, <span class="dv">5</span>)</a></code></pre></div>
<pre><code>#    direct  indirect     total 
# -5.93e-03 -1.01e-05 -5.94e-03</code></pre>
<p>The experimental <code>evalues=</code> approach which is known to be numerically exact by definition gives the same results as the matrix power series trace approach, so the slight difference may be attributed to the consequences of inverting the spatial process matrix.</p>
<div class="sourceCode" id="cb643"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb643-1" title="1"><span class="kw">sapply</span>(<span class="kw">impacts</span>(SLM_<span class="dv">489</span>, <span class="dt">evalues=</span>eigs_<span class="dv">489</span>), <span class="st">&quot;[&quot;</span>, <span class="dv">5</span>)</a></code></pre></div>
<pre><code>#    direct  indirect     total 
# -5.93e-03 -1.01e-05 -5.94e-03</code></pre>
<p>Impacts are crucial to the interpretation of Durbin models including spatially lagged covariates and models including the spatially lagged response. Tools to calculate impacts and their inferential bases are now available, and should be employed, but as yet some implementation details are under development and ways of presenting results in tabular form have not reached maturity.</p>
</div>
<div id="predictions" class="section level3">
<h3><span class="header-section-number">14.3.3</span> Predictions</h3>
<p>We will use the <code>predict()</code> method for <code>"sarlm"</code> objects to double-check impacts, here for the pupil-teacher ratio (<code>PTRATIO</code>). The method was re-written by Martin Gubri based on Goulard, Laurent and Thomas-Agnan <span class="citation">(<a href="#ref-goulardetal:17">2017</a>)</span>. The <code>pred.type=</code> argument specifies the prediction strategy among those presented in the article.</p>
<div class="sourceCode" id="cb645"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb645-1" title="1"><span class="kw">args</span>(<span class="kw">getS3method</span>(<span class="st">&quot;predict&quot;</span>, <span class="st">&quot;sarlm&quot;</span>))</a></code></pre></div>
<pre><code># function (object, newdata = NULL, listw = NULL, pred.type = &quot;TS&quot;, 
#     all.data = FALSE, zero.policy = NULL, legacy = TRUE, legacy.mixed = FALSE, 
#     power = NULL, order = 250, tol = .Machine$double.eps^(3/5), 
#     spChk = NULL, ...) 
# NULL</code></pre>
<p>First we’ll increment <code>PTRATIO</code> by one to show that, using least squares, the mean difference between predictions from the incremented new data and fitted values is equal to the regression coefficient.</p>
<div class="sourceCode" id="cb647"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb647-1" title="1">nd_<span class="dv">489</span> &lt;-<span class="st"> </span>boston_<span class="dv">489</span></a>
<a class="sourceLine" id="cb647-2" title="2">nd_<span class="dv">489</span><span class="op">$</span>PTRATIO &lt;-<span class="st"> </span>nd_<span class="dv">489</span><span class="op">$</span>PTRATIO <span class="op">+</span><span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb647-3" title="3">OLS_<span class="dv">489</span> &lt;-<span class="st"> </span><span class="kw">lm</span>(form, <span class="dt">data=</span>boston_<span class="dv">489</span>)</a>
<a class="sourceLine" id="cb647-4" title="4">fitted &lt;-<span class="st"> </span><span class="kw">predict</span>(OLS_<span class="dv">489</span>)</a>
<a class="sourceLine" id="cb647-5" title="5">nd_fitted &lt;-<span class="st"> </span><span class="kw">predict</span>(OLS_<span class="dv">489</span>, <span class="dt">newdata=</span>nd_<span class="dv">489</span>)</a>
<a class="sourceLine" id="cb647-6" title="6"><span class="kw">all.equal</span>(<span class="kw">unname</span>(<span class="kw">coef</span>(OLS_<span class="dv">489</span>)[<span class="dv">12</span>]), <span class="kw">mean</span>(nd_fitted <span class="op">-</span><span class="st"> </span>fitted))</a></code></pre></div>
<pre><code># [1] TRUE</code></pre>
<p>In models including the spatially lagged response, and when the spatial coefficient in different from zero, this is not the case in general, and is why we need <code>impacts()</code> methods. The difference here is not great, but neither is it zero, and needs to be handled.</p>
<div class="sourceCode" id="cb649"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb649-1" title="1">fitted &lt;-<span class="st"> </span><span class="kw">predict</span>(SLM_<span class="dv">489</span>)</a></code></pre></div>
<pre><code># This method assumes the response is known - see manual page</code></pre>
<div class="sourceCode" id="cb651"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb651-1" title="1">nd_fitted &lt;-<span class="st"> </span><span class="kw">predict</span>(SLM_<span class="dv">489</span>, <span class="dt">newdata=</span>nd_<span class="dv">489</span>, <span class="dt">listw=</span>lw_q_<span class="dv">489</span>, <span class="dt">pred.type=</span><span class="st">&quot;TS&quot;</span>,</a>
<a class="sourceLine" id="cb651-2" title="2">                     <span class="dt">zero.policy=</span><span class="ot">TRUE</span>)</a>
<a class="sourceLine" id="cb651-3" title="3"><span class="kw">all.equal</span>(<span class="kw">unname</span>(coef_SLM_<span class="dv">489</span>[<span class="dv">13</span>]), <span class="kw">mean</span>(nd_fitted <span class="op">-</span><span class="st"> </span>fitted))</a></code></pre></div>
<pre><code># [1] &quot;Mean relative difference: 0.00178&quot;</code></pre>
<p>In the Boston tracts data set, 17 observations of median house values, the response, are censored. Using these as an example and comparing some <code>pred.type=</code> variants for the SDEM model and predicting out-of-sample, we can see that there are differences, suggesting that this is a fruitful area for study. There have been a number of alternative proposals for handling missing variables <span class="citation">(Gómez-Rubio, Bivand, and Rue <a href="#ref-GOMEZRUBIO2015116">2015</a>; Suesse <a href="#ref-suesse:18">2018</a>)</span>. Another reason for increasing attention on prediction is that it is fundamental for machine learning approaches, in which prediction for validation and test data sets drives model specification choice. The choice of training and other data sets with dependent spatial data remains an open question, and is certainly not as simple as with independent data.</p>
<p>Here, we’ll list the predictions for the censored tract observations using three different prediction types, taking the exponent to get back to the USD median house values.</p>
<div class="sourceCode" id="cb653"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb653-1" title="1">nd &lt;-<span class="st"> </span>boston_<span class="dv">506</span>[<span class="kw">is.na</span>(boston_<span class="dv">506</span><span class="op">$</span>median),]</a>
<a class="sourceLine" id="cb653-2" title="2">t0 &lt;-<span class="st"> </span><span class="kw">exp</span>(<span class="kw">predict</span>(SDEM_<span class="dv">489</span>, <span class="dt">newdata=</span>nd, <span class="dt">listw=</span>lw_q, <span class="dt">pred.type=</span><span class="st">&quot;TS&quot;</span>, <span class="dt">zero.policy=</span><span class="ot">TRUE</span>))</a>
<a class="sourceLine" id="cb653-3" title="3"><span class="kw">suppressWarnings</span>(t1  &lt;-<span class="st"> </span><span class="kw">exp</span>(<span class="kw">predict</span>(SDEM_<span class="dv">489</span>, <span class="dt">newdata=</span>nd, <span class="dt">listw=</span>lw_q, <span class="dt">pred.type=</span><span class="st">&quot;KP2&quot;</span>,</a>
<a class="sourceLine" id="cb653-4" title="4">                                    <span class="dt">zero.policy=</span><span class="ot">TRUE</span>)))</a>
<a class="sourceLine" id="cb653-5" title="5"><span class="kw">suppressWarnings</span>(t2  &lt;-<span class="st"> </span><span class="kw">exp</span>(<span class="kw">predict</span>(SDEM_<span class="dv">489</span>, <span class="dt">newdata=</span>nd, <span class="dt">listw=</span>lw_q, <span class="dt">pred.type=</span><span class="st">&quot;KP5&quot;</span>,</a>
<a class="sourceLine" id="cb653-6" title="6">                                    <span class="dt">zero.policy=</span><span class="ot">TRUE</span>)))</a>
<a class="sourceLine" id="cb653-7" title="7"><span class="kw">data.frame</span>(<span class="dt">fit_TS=</span>t0[,<span class="dv">1</span>], <span class="dt">fit_KP2=</span><span class="kw">c</span>(t1), <span class="dt">fit_KP5=</span><span class="kw">c</span>(t2),</a>
<a class="sourceLine" id="cb653-8" title="8">           <span class="dt">censored=</span>boston_<span class="dv">506</span><span class="op">$</span>censored[<span class="kw">as.integer</span>(<span class="kw">attr</span>(t0, <span class="st">&quot;region.id&quot;</span>))])</a></code></pre></div>
<pre><code>#     fit_TS fit_KP2 fit_KP5 censored
# 13   23912   29477   28147    right
# 14   28126   27001   28516    right
# 15   30553   36184   32476    right
# 17   18518   19621   18878    right
# 43    9564    6817    7561     left
# 50    8371    7196    7383     left
# 312  51477   53301   54173    right
# 313  45921   45823   47095    right
# 314  44196   44586   45361    right
# 317  43427   45707   45442    right
# 337  39879   42072   41127    right
# 346  44708   46694   46108    right
# 355  48188   49068   48911    right
# 376  42881   45883   44966    right
# 408  44294   44615   45670    right
# 418  38211   43375   41914    right
# 434  41647   41690   42398    right</code></pre>
</div>
</div>
<div id="markov-random-field-and-multilevel-models-with-spatial-weights" class="section level2">
<h2><span class="header-section-number">14.4</span> Markov random field and multilevel models with spatial weights</h2>
<p>There is a large literature in spatial epidemiology using CAR and ICAR models in spatially structured random effects. These extend to multilevel models, in which the spatially structured random effects may apply at different levels of the model <span class="citation">(Roger S. Bivand et al. <a href="#ref-bivandetal17a">2017</a>)</span>. In order to try out some of the variants, we need to remove the no-neighbour observations from the tract level, and from the model output zone aggregated level, in two steps as reducing the tract level induces a no-neighbour outcome at the model output zone level.</p>
<div class="sourceCode" id="cb655"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb655-1" title="1">boston_94a &lt;-<span class="st"> </span><span class="kw">aggregate</span>(boston_<span class="dv">489</span>[,<span class="st">&quot;NOX_ID&quot;</span>], <span class="kw">list</span>(boston_<span class="dv">489</span><span class="op">$</span>NOX_ID), unique)</a>
<a class="sourceLine" id="cb655-2" title="2">nb_q_94a &lt;-<span class="st"> </span>spdep<span class="op">::</span><span class="kw">poly2nb</span>(boston_94a)</a>
<a class="sourceLine" id="cb655-3" title="3">NOX_ID_no_neighs &lt;-<span class="st"> </span>boston_94a<span class="op">$</span>NOX_ID[<span class="kw">which</span>(spdep<span class="op">::</span><span class="kw">card</span>(nb_q_94a) <span class="op">==</span><span class="st"> </span><span class="dv">0</span>)]</a>
<a class="sourceLine" id="cb655-4" title="4">boston_<span class="dv">487</span> &lt;-<span class="st"> </span>boston_<span class="dv">489</span>[<span class="kw">is.na</span>(<span class="kw">match</span>(boston_<span class="dv">489</span><span class="op">$</span>NOX_ID, NOX_ID_no_neighs)),]</a>
<a class="sourceLine" id="cb655-5" title="5">boston_<span class="dv">93</span> &lt;-<span class="st"> </span><span class="kw">aggregate</span>(boston_<span class="dv">487</span>[, <span class="st">&quot;NOX_ID&quot;</span>], <span class="kw">list</span>(<span class="dt">ids =</span> boston_<span class="dv">487</span><span class="op">$</span>NOX_ID), unique)</a>
<a class="sourceLine" id="cb655-6" title="6"><span class="kw">row.names</span>(boston_<span class="dv">93</span>) &lt;-<span class="st"> </span><span class="kw">as.character</span>(boston_<span class="dv">93</span><span class="op">$</span>NOX_ID)</a>
<a class="sourceLine" id="cb655-7" title="7">nb_q_<span class="dv">93</span> &lt;-<span class="st"> </span>spdep<span class="op">::</span><span class="kw">poly2nb</span>(boston_<span class="dv">93</span>, <span class="dt">row.names=</span><span class="kw">unique</span>(<span class="kw">as.character</span>(boston_<span class="dv">93</span><span class="op">$</span>NOX_ID)))</a></code></pre></div>
<p>The <strong>lme4</strong> package lets us add an IID unstructured random effect at the model output zone level:</p>
<div class="sourceCode" id="cb656"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb656-1" title="1"><span class="kw">library</span>(lme4)</a>
<a class="sourceLine" id="cb656-2" title="2">MLM &lt;-<span class="st"> </span><span class="kw">lmer</span>(<span class="kw">update</span>(form, . <span class="op">~</span><span class="st"> </span>. <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">|</span><span class="st"> </span>NOX_ID)), <span class="dt">data=</span>boston_<span class="dv">487</span>, <span class="dt">REML=</span><span class="ot">FALSE</span>)</a></code></pre></div>
<p>copying the random effect into the <code>"sf"</code> object for mapping below.</p>
<div class="sourceCode" id="cb657"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb657-1" title="1">boston_<span class="dv">93</span><span class="op">$</span>MLM_re &lt;-<span class="st"> </span><span class="kw">ranef</span>(MLM)[[<span class="dv">1</span>]][,<span class="dv">1</span>]</a></code></pre></div>
<p>Two packages, <strong>hglm</strong> and <strong>HSAR</strong>, offer SAR upper level spatially structured random effects, and require the specification of a sparse matrix mapping the upper level enities onto lower level entities, and sparse binary weights matrices:</p>
<div class="sourceCode" id="cb658"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb658-1" title="1"><span class="kw">library</span>(Matrix)</a>
<a class="sourceLine" id="cb658-2" title="2"><span class="kw">suppressMessages</span>(<span class="kw">library</span>(MatrixModels))</a>
<a class="sourceLine" id="cb658-3" title="3">Delta &lt;-<span class="st"> </span><span class="kw">as</span>(<span class="kw">model.Matrix</span>(<span class="op">~</span><span class="st"> </span><span class="dv">-1</span> <span class="op">+</span><span class="st"> </span><span class="kw">as.factor</span>(NOX_ID), <span class="dt">data=</span>boston_<span class="dv">487</span>, <span class="dt">sparse=</span><span class="ot">TRUE</span>),</a>
<a class="sourceLine" id="cb658-4" title="4">            <span class="st">&quot;dgCMatrix&quot;</span>)</a>
<a class="sourceLine" id="cb658-5" title="5">M &lt;-<span class="st"> </span><span class="kw">as</span>(spdep<span class="op">::</span><span class="kw">nb2listw</span>(nb_q_<span class="dv">93</span>, <span class="dt">style=</span><span class="st">&quot;B&quot;</span>), <span class="st">&quot;CsparseMatrix&quot;</span>)</a></code></pre></div>
<p>The extension of <strong>hglm</strong> to sparse spatial setting extended its facilities <span class="citation">(Alam, Rönnegård, and Shen <a href="#ref-alam-ronnegard-shen:2015">2015</a>)</span>, and also permits the modelling of discrete responses. First we fit an IID random effect:</p>
<div class="sourceCode" id="cb659"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb659-1" title="1"><span class="kw">suppressPackageStartupMessages</span>(<span class="kw">library</span>(hglm))</a>
<a class="sourceLine" id="cb659-2" title="2">y_hglm &lt;-<span class="st"> </span><span class="kw">log</span>(boston_<span class="dv">487</span><span class="op">$</span>median)</a>
<a class="sourceLine" id="cb659-3" title="3">X_hglm &lt;-<span class="st"> </span><span class="kw">model.matrix</span>(<span class="kw">lm</span>(form, <span class="dt">data=</span>boston_<span class="dv">487</span>))</a>
<a class="sourceLine" id="cb659-4" title="4"><span class="kw">suppressWarnings</span>(HGLM_iid &lt;-<span class="st"> </span><span class="kw">hglm</span>(<span class="dt">y=</span>y_hglm, <span class="dt">X=</span>X_hglm, <span class="dt">Z=</span>Delta))</a></code></pre></div>
<p>followed by a SAR model at the upper level (corresponding to a spatial error (SEM) model), which reports the spatially structured random effect without fully converging, so coefficient standard errors are not available:</p>
<div class="sourceCode" id="cb660"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb660-1" title="1"><span class="kw">suppressWarnings</span>(HGLM_sar &lt;-<span class="st"> </span><span class="kw">hglm</span>(<span class="dt">y=</span>y_hglm, <span class="dt">X=</span>X_hglm, <span class="dt">Z=</span>Delta, <span class="dt">rand.family=</span><span class="kw">SAR</span>(<span class="dt">D=</span>M)))</a>
<a class="sourceLine" id="cb660-2" title="2">boston_<span class="dv">93</span><span class="op">$</span>HGLM_re &lt;-<span class="st"> </span><span class="kw">unname</span>(HGLM_iid<span class="op">$</span>ranef)</a>
<a class="sourceLine" id="cb660-3" title="3">boston_<span class="dv">93</span><span class="op">$</span>HGLM_ss &lt;-<span class="st"> </span>HGLM_sar<span class="op">$</span>ranef[,<span class="dv">1</span>]</a></code></pre></div>
<p>The <strong>HSAR</strong> package is restricted to the Gaussian response case, and fits an upper level SEM using MCMC; if <code>W=</code> is a lower level weights matrix, it will also fit a lower level SLM <span class="citation">(Dong and Harris <a href="#ref-dong15">2015</a>; Dong et al. <a href="#ref-dongetal15">2015</a>)</span>:</p>
<div class="sourceCode" id="cb661"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb661-1" title="1"><span class="kw">library</span>(HSAR)</a>
<a class="sourceLine" id="cb661-2" title="2"><span class="kw">suppressWarnings</span>(HSAR &lt;-<span class="st"> </span><span class="kw">hsar</span>(form, <span class="dt">data=</span>boston_<span class="dv">487</span>, <span class="dt">W=</span><span class="ot">NULL</span>, <span class="dt">M=</span>M, <span class="dt">Delta=</span>Delta, </a>
<a class="sourceLine" id="cb661-3" title="3">                              <span class="dt">burnin=</span><span class="dv">500</span>, <span class="dt">Nsim=</span><span class="dv">2500</span>, <span class="dt">thinning=</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb661-4" title="4">boston_<span class="dv">93</span><span class="op">$</span>HSAR_ss &lt;-<span class="st"> </span>HSAR<span class="op">$</span>Mus[<span class="dv">1</span>,]</a></code></pre></div>
<p>The <strong>R2BayesX</strong> package provides flexible support for structured additive regression models, including spatial multilevel models. The models include an IID unstructured random effect at the upper level using the <code>"re"</code> specification <span class="citation">(Umlauf et al. <a href="#ref-umlaufetal:15">2015</a>)</span>; we choose the <code>"MCMC"</code>method:</p>
<div class="sourceCode" id="cb662"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb662-1" title="1"><span class="kw">suppressPackageStartupMessages</span>(<span class="kw">library</span>(R2BayesX))</a>
<a class="sourceLine" id="cb662-2" title="2">BX_iid &lt;-<span class="st"> </span><span class="kw">bayesx</span>(<span class="kw">update</span>(form, . <span class="op">~</span><span class="st"> </span>. <span class="op">+</span><span class="st"> </span><span class="kw">sx</span>(NOX_ID, <span class="dt">bs=</span><span class="st">&quot;re&quot;</span>)), <span class="dt">family=</span><span class="st">&quot;gaussian&quot;</span>,</a>
<a class="sourceLine" id="cb662-3" title="3"><span class="dt">data=</span>boston_<span class="dv">487</span>, <span class="dt">method=</span><span class="st">&quot;MCMC&quot;</span>, <span class="dt">iterations=</span><span class="dv">12000</span>, <span class="dt">burnin=</span><span class="dv">2000</span>, <span class="dt">step=</span><span class="dv">2</span>, <span class="dt">seed=</span><span class="dv">123</span>)</a></code></pre></div>
<pre><code># Warning in run.bayesx(file.path(res$bayesx.prg$file.dir, prg.name =
# res$bayesx.prg$prg.name), : an error occurred during runtime of BayesX, please
# check the BayesX logfile!</code></pre>
<div class="sourceCode" id="cb664"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb664-1" title="1">boston_<span class="dv">93</span><span class="op">$</span>BX_re &lt;-<span class="st"> </span>BX_iid<span class="op">$</span>effects[<span class="st">&quot;sx(NOX_ID):re&quot;</span>][[<span class="dv">1</span>]]<span class="op">$</span>Mean</a></code></pre></div>
<p>and the <code>"mrf"</code> (Markov random field) spatially structured random effect specification based on a graph derived from converting a suitable <code>"nb"</code> object for the upper level. The <code>"region.id"</code> attribute of the <code>"nb"</code> object needs to contain values corresponding the the indexing variable.</p>
<div class="sourceCode" id="cb665"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb665-1" title="1">RBX_gra &lt;-<span class="st"> </span><span class="kw">nb2gra</span>(nb_q_<span class="dv">93</span>)</a>
<a class="sourceLine" id="cb665-2" title="2">BX_mrf &lt;-<span class="st"> </span><span class="kw">bayesx</span>(<span class="kw">update</span>(form, . <span class="op">~</span><span class="st"> </span>. <span class="op">+</span><span class="st"> </span><span class="kw">sx</span>(NOX_ID, <span class="dt">bs=</span><span class="st">&quot;mrf&quot;</span>, <span class="dt">map=</span>RBX_gra)), </a>
<a class="sourceLine" id="cb665-3" title="3">                 <span class="dt">family=</span><span class="st">&quot;gaussian&quot;</span>, <span class="dt">data=</span>boston_<span class="dv">487</span>, <span class="dt">method=</span><span class="st">&quot;MCMC&quot;</span>, </a>
<a class="sourceLine" id="cb665-4" title="4">                 <span class="dt">iterations=</span><span class="dv">12000</span>, <span class="dt">burnin=</span><span class="dv">2000</span>,<span class="dt">step=</span><span class="dv">2</span>, <span class="dt">seed=</span><span class="dv">123</span>)</a></code></pre></div>
<pre><code># Warning in run.bayesx(file.path(res$bayesx.prg$file.dir, prg.name =
# res$bayesx.prg$prg.name), : an error occurred during runtime of BayesX, please
# check the BayesX logfile!</code></pre>
<div class="sourceCode" id="cb667"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb667-1" title="1">boston_<span class="dv">93</span><span class="op">$</span>BX_ss &lt;-<span class="st"> </span>BX_mrf<span class="op">$</span>effects[<span class="st">&quot;sx(NOX_ID):mrf&quot;</span>][[<span class="dv">1</span>]]<span class="op">$</span>Mean</a></code></pre></div>
<p>In a very similar way, <code>mgcv::gam()</code> can take an <code>"mrf"</code> term using a suitable <code>"nb"</code> object for the upper level. In this case the <code>"nb"</code> object needs to have the contents of the <code>"region.id"</code> attribute copied as the names of the neighbour list components, and the indexing variable needs to be a factor <span class="citation">(Wood <a href="#ref-wood:17">2017</a>)</span> (the <code>"REML"</code> method of <code>bayesx()</code> gives the same result here):</p>
<div class="sourceCode" id="cb668"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb668-1" title="1"><span class="kw">library</span>(mgcv)</a>
<a class="sourceLine" id="cb668-2" title="2"><span class="kw">names</span>(nb_q_<span class="dv">93</span>) &lt;-<span class="st"> </span><span class="kw">attr</span>(nb_q_<span class="dv">93</span>, <span class="st">&quot;region.id&quot;</span>)</a>
<a class="sourceLine" id="cb668-3" title="3">boston_<span class="dv">487</span><span class="op">$</span>NOX_ID &lt;-<span class="st"> </span><span class="kw">as.factor</span>(boston_<span class="dv">487</span><span class="op">$</span>NOX_ID)</a>
<a class="sourceLine" id="cb668-4" title="4">GAM_MRF &lt;-<span class="st"> </span><span class="kw">gam</span>(<span class="kw">update</span>(form, . <span class="op">~</span><span class="st"> </span>. <span class="op">+</span><span class="st"> </span><span class="kw">s</span>(NOX_ID, <span class="dt">bs=</span><span class="st">&quot;mrf&quot;</span>, <span class="dt">xt=</span><span class="kw">list</span>(<span class="dt">nb=</span>nb_q_<span class="dv">93</span>))),</a>
<a class="sourceLine" id="cb668-5" title="5">               <span class="dt">data=</span>boston_<span class="dv">487</span>, <span class="dt">method=</span><span class="st">&quot;REML&quot;</span>)</a>
<a class="sourceLine" id="cb668-6" title="6">boston_<span class="dv">93</span><span class="op">$</span>GAM_ss &lt;-<span class="st"> </span><span class="kw">aggregate</span>(<span class="kw">predict</span>(GAM_MRF, <span class="dt">type=</span><span class="st">&quot;terms&quot;</span>, <span class="dt">se=</span><span class="ot">FALSE</span>)[,<span class="dv">14</span>],</a>
<a class="sourceLine" id="cb668-7" title="7">                              <span class="kw">list</span>(boston_<span class="dv">487</span><span class="op">$</span>NOX_ID), mean)<span class="op">$</span>x</a></code></pre></div>
<p>In the cases of <code>hglm()</code>, <code>bayesx()</code> and <code>gam()</code>, we could also model discrete responses without further major difficulty, and <code>bayesx()</code> and <code>gam()</code> also facilitate the generalization of functional form fitting for included covariates.</p>
<div class="sourceCode" id="cb669"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb669-1" title="1">res &lt;-<span class="st"> </span><span class="kw">rbind</span>(<span class="dt">iid_lmer=</span><span class="kw">summary</span>(MLM)<span class="op">$</span>coefficients[<span class="dv">6</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>],</a>
<a class="sourceLine" id="cb669-2" title="2">             <span class="dt">iid_hglm=</span><span class="kw">summary</span>(HGLM_iid)<span class="op">$</span>FixCoefMat[<span class="dv">6</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>], </a>
<a class="sourceLine" id="cb669-3" title="3">             <span class="dt">iid_BX=</span>BX_iid<span class="op">$</span>fixed.effects[<span class="dv">6</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>], </a>
<a class="sourceLine" id="cb669-4" title="4">             <span class="dt">sar_hsar=</span><span class="kw">c</span>(HSAR<span class="op">$</span>Mbetas[<span class="dv">1</span>, <span class="dv">6</span>], HSAR<span class="op">$</span>SDbetas[<span class="dv">1</span>, <span class="dv">6</span>]),</a>
<a class="sourceLine" id="cb669-5" title="5">             <span class="dt">mrf_BX=</span>BX_mrf<span class="op">$</span>fixed.effects[<span class="dv">6</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>], </a>
<a class="sourceLine" id="cb669-6" title="6">             <span class="dt">mrf_GAM=</span><span class="kw">c</span>(<span class="kw">summary</span>(GAM_MRF)<span class="op">$</span>p.coeff[<span class="dv">6</span>], <span class="kw">summary</span>(GAM_MRF)<span class="op">$</span>se[<span class="dv">6</span>]))</a></code></pre></div>
<p>Unfortunately, the coefficient estimates for the air pollution variable for these multilevel models are not helpful. All remain negative, but the inclusion of the model output zone level effects, be they IID or spatially structured, suggest that it is hard to disentangle the influence of the scale of observation from that of covariates observed at that scale.</p>
<div class="sourceCode" id="cb670"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb670-1" title="1"><span class="kw">suppressPackageStartupMessages</span>(<span class="kw">library</span>(ggplot2))</a>
<a class="sourceLine" id="cb670-2" title="2">df_res &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(res)</a>
<a class="sourceLine" id="cb670-3" title="3"><span class="kw">names</span>(df_res) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;mean&quot;</span>, <span class="st">&quot;sd&quot;</span>)</a>
<a class="sourceLine" id="cb670-4" title="4">limits &lt;-<span class="st"> </span><span class="kw">aes</span>(<span class="dt">ymax =</span> mean <span class="op">+</span><span class="st"> </span><span class="kw">qnorm</span>(<span class="fl">0.975</span>)<span class="op">*</span>sd, <span class="dt">ymin=</span>mean <span class="op">+</span><span class="st"> </span><span class="kw">qnorm</span>(<span class="fl">0.025</span>)<span class="op">*</span>sd)</a>
<a class="sourceLine" id="cb670-5" title="5">df_res<span class="op">$</span>model &lt;-<span class="st"> </span><span class="kw">row.names</span>(df_res)</a>
<a class="sourceLine" id="cb670-6" title="6">p &lt;-<span class="st"> </span><span class="kw">ggplot</span>(df_res, <span class="kw">aes</span>(<span class="dt">y=</span>mean, <span class="dt">x=</span>model)) <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_errorbar</span>(limits) <span class="op">+</span><span class="st"> </span><span class="kw">geom_hline</span>(<span class="dt">yintercept =</span> <span class="dv">0</span>, <span class="dt">col=</span><span class="st">&quot;#EB811B&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">coord_flip</span>()</a>
<a class="sourceLine" id="cb670-7" title="7">p <span class="op">+</span><span class="st"> </span><span class="kw">ggtitle</span>(<span class="st">&quot;NOX coefficients and error bars&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="kw">theme</span>(<span class="dt">plot.background =</span> <span class="kw">element_rect</span>(<span class="dt">fill =</span> <span class="st">&quot;transparent&quot;</span>,<span class="dt">colour =</span> <span class="ot">NA</span>), <span class="dt">legend.background =</span> <span class="kw">element_rect</span>(<span class="dt">colour =</span> <span class="ot">NA</span>, <span class="dt">fill =</span> <span class="st">&quot;transparent&quot;</span>))</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:multi-levelcoefs"></span>
<img src="sds_files/figure-html/multi-levelcoefs-1.png" alt="Polish municipality types 2015" width="100%" />
<p class="caption">
Figure 14.1: Polish municipality types 2015
</p>
</div>
<p>This map shows that the model output zone level IID random effects are very similar across the three model fitting functions reported.</p>
<div class="sourceCode" id="cb671"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb671-1" title="1"><span class="kw">library</span>(tmap)</a>
<a class="sourceLine" id="cb671-2" title="2"><span class="co"># </span><span class="al">FIXME</span><span class="co">: uncommented BX_re</span></a>
<a class="sourceLine" id="cb671-3" title="3"><span class="kw">tm_shape</span>(boston_<span class="dv">93</span>) <span class="op">+</span><span class="st"> </span><span class="kw">tm_fill</span>(<span class="kw">c</span>(<span class="st">&quot;MLM_re&quot;</span>, <span class="st">&quot;HGLM_re&quot;</span> <span class="co">#, &quot;BX_re&quot;</span></a>
<a class="sourceLine" id="cb671-4" title="4">                                ), <span class="dt">midpoint=</span><span class="dv">0</span>, <span class="dt">title=</span><span class="st">&quot;IID&quot;</span>)  <span class="op">+</span><span class="st"> </span><span class="kw">tm_facets</span>(<span class="dt">free.scales=</span><span class="ot">FALSE</span>) <span class="op">+</span><span class="st"> </span><span class="kw">tm_borders</span>(<span class="dt">lwd=</span><span class="fl">0.3</span>, <span class="dt">alpha=</span><span class="fl">0.4</span>) <span class="op">+</span><span class="st"> </span><span class="kw">tm_layout</span>(<span class="dt">panel.labels=</span><span class="kw">c</span>(<span class="st">&quot;MLM&quot;</span>, <span class="st">&quot;HGLM&quot;</span>, <span class="st">&quot;BX&quot;</span>))</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:multi-levelmaps1"></span>
<img src="sds_files/figure-html/multi-levelmaps1-1.png" alt="IID random effects" width="100%" />
<p class="caption">
Figure 14.2: IID random effects
</p>
</div>
<p>The spatially structured SAR and MRF random effects (MRF term in the <code>gam()</code> case) are also very similar, with the MRF somewhat less smoothed than the SAR values.</p>
<div class="sourceCode" id="cb672"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb672-1" title="1"><span class="co"># </span><span class="al">FIXME</span><span class="co">: uncommented BX_ss</span></a>
<a class="sourceLine" id="cb672-2" title="2"><span class="kw">tm_shape</span>(boston_<span class="dv">93</span>) <span class="op">+</span><span class="st"> </span><span class="kw">tm_fill</span>(<span class="kw">c</span>(<span class="st">&quot;HGLM_ss&quot;</span>, <span class="st">&quot;HSAR_ss&quot;</span>, <span class="co"># &quot;BX_ss&quot;, </span></a>
<a class="sourceLine" id="cb672-3" title="3">  <span class="st">&quot;GAM_ss&quot;</span>), <span class="dt">midpoint=</span><span class="dv">0</span>, <span class="dt">title=</span><span class="st">&quot;SS&quot;</span>)  <span class="op">+</span><span class="st"> </span><span class="kw">tm_facets</span>(<span class="dt">free.scales=</span><span class="ot">FALSE</span>) <span class="op">+</span><span class="st"> </span><span class="kw">tm_borders</span>(<span class="dt">lwd=</span><span class="fl">0.3</span>, <span class="dt">alpha=</span><span class="fl">0.4</span>) <span class="op">+</span><span class="st"> </span><span class="kw">tm_layout</span>(<span class="dt">panel.labels=</span><span class="kw">c</span>(<span class="st">&quot;HGLM SAR&quot;</span>, <span class="st">&quot;HSAR SAR&quot;</span>, <span class="st">&quot;BX MRF&quot;</span>, <span class="st">&quot;GAM MRF&quot;</span>))</a></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:multilevelmaps2"></span>
<img src="sds_files/figure-html/multilevelmaps2-1.png" alt="Spatially structured random effects" width="100%" />
<p class="caption">
Figure 14.3: Spatially structured random effects
</p>
</div>
<p>Although there is still a great need for more thorough comparative studies of model fitting functions for spatial regression, there has been much progress over recent years.</p>

</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-alam-ronnegard-shen:2015">
<p>Alam, Moudud, Lars Rönnegård, and Xia Shen. 2015. “Fitting Conditional and Simultaneous Autoregressive Spatial Models in Hglm.” <em>The R Journal</em> 7 (2): 5–18. <a href="https://doi.org/10.32614/RJ-2015-017">https://doi.org/10.32614/RJ-2015-017</a>.</p>
</div>
<div id="ref-a88">
<p>Anselin, L. 1988. <em>Spatial Econometrics: Methods and Models</em>. Kluwer Academic Publishers.</p>
</div>
<div id="ref-besag:74">
<p>Besag, Julian. 1974. “Spatial Interaction and the Statistical Analysis of Lattice Systems.” <em>Journal of the Royal Statistical Society. Series B (Methodological)</em> 36: pp. 192–236.</p>
</div>
<div id="ref-bivand17">
<p>Bivand, Roger. 2017. “Revisiting the Boston Data Set — Changing the Units of Observation Affects Estimated Willingness to Pay for Clean Air.” <em>REGION</em> 4 (1): 109–27. <a href="https://doi.org/10.18335/region.v4i1.107">https://doi.org/10.18335/region.v4i1.107</a>.</p>
</div>
<div id="ref-bivand:12">
<p>Bivand, Roger S. 2012. “After ’Raising the Bar’: Applied Maximum Likelihood Estimation of Families of Models in Spatial Econometrics.” <em>Estadística Española</em> 54: 71–88.</p>
</div>
<div id="ref-bivandetal13">
<p>Bivand, Roger S., Jan Hauke, and Tomasz Kossowski. 2013. “Computing the Jacobian in Gaussian Spatial Autoregressive Models: An Illustrated Comparison of Available Methods.” <em>Geographical Analysis</em> 45 (2): 150–79. <a href="https://doi.org/10.1111/gean.12008">https://doi.org/10.1111/gean.12008</a>.</p>
</div>
<div id="ref-bivand+piras:15">
<p>Bivand, Roger S., and Gianfranco Piras. 2015. “Comparing Implementations of Estimation Methods for Spatial Econometrics.” <em>Journal of Statistical Software</em> 63 (1): 1–36. <a href="https://doi.org/10.18637/jss.v063.i18">https://doi.org/10.18637/jss.v063.i18</a>.</p>
</div>
<div id="ref-bivandetal17a">
<p>Bivand, Roger S., Zhe Sha, Liv Osland, and Ingrid Sandvig Thorsen. 2017. “A Comparison of Estimation Methods for Multilevel Models of Spatially Structured Data.” <em>Spatial Statistics</em>. <a href="https://doi.org/10.1016/j.spasta.2017.01.002">https://doi.org/10.1016/j.spasta.2017.01.002</a>.</p>
</div>
<div id="ref-bivand:84">
<p>Bivand, R. S. 1984. “Regression Modeling with Spatial Dependence: an Application of Some Class Selection and Estimation Methods.” <em>Geographical Analysis</em> 16: 25–37.</p>
</div>
<div id="ref-bivand:02">
<p>Bivand, R. 2002. “Spatial Econometrics Functions in R: Classes and Methods.” <em>Journal of Geographical Systems</em> 4: 405–21.</p>
</div>
<div id="ref-brookesetal:17">
<p>Brooks, Mollie E., Kasper Kristensen, Koen J. van Benthem, Arni Magnusson, Casper W. Berg, Anders Nielsen, Hans J. Skaug, Martin Maechler, and Benjamin M. Bolker. 2017. “glmmTMB Balances Speed and Flexibility Among Packages for Zero-Inflated Generalized Linear Mixed Modeling.” <em>The R Journal</em> 9 (2): 378–400. <a href="https://journal.r-project.org/archive/2017/RJ-2017-066/index.html">https://journal.r-project.org/archive/2017/RJ-2017-066/index.html</a>.</p>
</div>
<div id="ref-burridge:81">
<p>Burridge, P. 1981. “Testing for a Common Factor in a Spatial Autoregression Model.” <em>Environment and Planning A</em> 13: 795–800.</p>
</div>
<div id="ref-cliff+ord:73">
<p>Cliff, A. D., and J. K. Ord. 1973. <em>Spatial Autocorrelation</em>. London: Pion.</p>
</div>
<div id="ref-cliff+ord:81">
<p>Cliff, A. 1981. <em>Spatial Processes</em>. London: Pion.</p>
</div>
<div id="ref-CliffOrd:72">
<p>Cliff, A., and J.K. Ord. 1972. “Testing for Spatial Autocorrelation Among Regression Residuals.” <em>Geographical Analysis</em> 4: 267–84.</p>
</div>
<div id="ref-Cressie:1993">
<p>Cressie, N. A. C. 1993. <em>Statistics for Spatial Data</em>. New York:Wiley.</p>
</div>
<div id="ref-dong15">
<p>Dong, G., and R. Harris. 2015. “Spatial Autorgressive Models for Geographically Hierarchical Data Structures.” <em>Geographical Analysis</em> 47 (2): 173–91.</p>
</div>
<div id="ref-dongetal15">
<p>Dong, G., R. Harris, K. Jones, and J. Yu. 2015. “Multilevel Modeling with Spatial Interaction Effects with Application to an Emerging Land Market in Beijing, China.” <em>PLOS One</em> 10 (6). <a href="https://doi.org/doi:10.1371/journal.pone.0130761">https://doi.org/doi:10.1371/journal.pone.0130761</a>.</p>
</div>
<div id="ref-elhorst:10">
<p>Elhorst, J. Paul. 2010. “Applied Spatial Econometrics: Raising the Bar.” <em>Spatial Economic Analysis</em> 5: 9–28.</p>
</div>
<div id="ref-fingleton:99">
<p>Fingleton, B. 1999. “Spurious spatial regression: Some Monte Carlo results with a spatial unit root and spatial cointegration.” <em>Journal of Regional Science</em> 9: 1–19.</p>
</div>
<div id="ref-gaetan+guyon:10">
<p>Gaetan, Carlo, and Xavier Guyon. 2010. <em>Spatial Statistics and Modeling</em>. New York: Springer.</p>
</div>
<div id="ref-GOMEZRUBIO2015116">
<p>Gómez-Rubio, Virgilio, Roger Bivand, and Håvard Rue. 2015. “A New Latent Class to Fit Spatial Econometrics Models with Integrated Nested Laplace Approximations.” <em>Procedia Environmental Sciences</em> 27: 116–18. <a href="https://doi.org/https://doi.org/10.1016/j.proenv.2015.07.119">https://doi.org/https://doi.org/10.1016/j.proenv.2015.07.119</a>.</p>
</div>
<div id="ref-goulardetal:17">
<p>Goulard, Michel, Thibault Laurent, and Christine Thomas-Agnan. 2017. “About Predictions in Spatial Autoregressive Models: Optimal and Almost Optimal Strategies.” <em>Spatial Economic Analysis</em> 12 (2-3): 304–25. <a href="https://doi.org/10.1080/17421772.2017.1300679">https://doi.org/10.1080/17421772.2017.1300679</a>.</p>
</div>
<div id="ref-GRIFFITH2015119">
<p>Griffith, Daniel, Roger Bivand, and Yongwan Chun. 2015. “Implementing Approximations to Extreme Eigenvalues and Eigenvalues of Irregular Surface Partitionings for Use in Sar and Car Models.” <em>Procedia Environmental Sciences</em> 26: 119–22. <a href="https://doi.org/https://doi.org/10.1016/j.proenv.2015.05.013">https://doi.org/https://doi.org/10.1016/j.proenv.2015.05.013</a>.</p>
</div>
<div id="ref-halleck-vega+elhorst:15">
<p>Halleck Vega, Solmaria, and J. Paul Elhorst. 2015. “The SLX Model.” <em>Journal of Regional Science</em> 55 (3): 339–63. <a href="https://doi.org/10.1111/jors.12188">https://doi.org/10.1111/jors.12188</a>.</p>
</div>
<div id="ref-hepple:76">
<p>Hepple, Leslie W. 1976. “A Maximum Likelihood Model for Econometric Estimation with Spatial Series.” In <em>Theory and Practice in Regional Science</em>, edited by I. Masser, 90–104. London Papers in Regional Science. London: Pion.</p>
</div>
<div id="ref-kaluznyetal:98">
<p>Kaluzny, S.P., S.C. Vega, T.P. Cardoso, and A.A. Shelly. 1998. <em>S+SpatialStats</em>. New York, NY: Springer.</p>
</div>
<div id="ref-kelejian+piras:17">
<p>Kelejian, Harry, and Gianfranco Piras. 2017. <em>Spatial Econometrics</em>. London: Academic Press.</p>
</div>
<div id="ref-lesage+pace:09">
<p>LeSage, James P., and Kelley R. Pace. 2009. <em>Introduction to Spatial Econometrics</em>. Boca Raton, FL: CRC Press.</p>
</div>
<div id="ref-lesage:14">
<p>LeSage, J. P. 2014. “What Regional Scientists Need to Know About Spatial Econometrics.” <em>Review of Regional Studies</em> 44: 13–32. <a href="https://journal.srsa.org/ojs/index.php/RRS/article/view/44.1.2">https://journal.srsa.org/ojs/index.php/RRS/article/view/44.1.2</a>.</p>
</div>
<div id="ref-vanlieshout:19">
<p>Lieshout, M. N. M. van. 2019. <em>Theory of Spatial Statistics</em>. Boca Raton, FL: Chapman; Hall/CRC.</p>
</div>
<div id="ref-MARTINETTI201730">
<p>Martinetti, Davide, and Ghislain Geniaux. 2017. “Approximate Likelihood Estimation of Spatial Probit Models.” <em>Regional Science and Urban Economics</em> 64: 30–45. <a href="https://doi.org/https://doi.org/10.1016/j.regsciurbeco.2017.02.002">https://doi.org/https://doi.org/10.1016/j.regsciurbeco.2017.02.002</a>.</p>
</div>
<div id="ref-mcmillen:13">
<p>McMillen, D. P. 2013. <em>Quantile Regression for Spatial Data</em>. Heidelberg: Springer-Verlag.</p>
</div>
<div id="ref-millo+piras:12">
<p>Millo, Giovanni, and Gianfranco Piras. 2012. “splm: Spatial Panel Data Models in R.” <em>Journal of Statistical Software</em> 47 (1): 1–38.</p>
</div>
<div id="ref-mur+angulo:06">
<p>Mur, Jesús, and Ana Angulo. 2006. “The Spatial Durbin Model and the Common Factor Tests.” <em>Spatial Economic Analysis</em> 1 (2): 207–26. <a href="https://doi.org/10.1080/17421770601009841">https://doi.org/10.1080/17421770601009841</a>.</p>
</div>
<div id="ref-ord:75">
<p>Ord, J. K. 1975. “Estimation Methods for Models of Spatial Interaction.” <em>Journal of the American Statistical Association</em> 70 (349): 120–26.</p>
</div>
<div id="ref-pace+barry:97a">
<p>Pace, R. K., and R. P. Barry. 1997a. “Fast CARs.” <em>Journal of Statistical Computation and Simulation</em> 59 (2): 123–45.</p>
</div>
<div id="ref-pace+barry:97d">
<p>Pace, R. 1997b. “Fast spatial estimation.” <em>Applied Economics Letters</em> 4 (5): 337–41.</p>
</div>
<div id="ref-pace+barry:97b">
<p>Pace, R. 1997c. “Quick computation of spatial autoregressive estimators.” <em>Geographics Analysis</em> 29 (3): 232–47.</p>
</div>
<div id="ref-pace+barry:97c">
<p>Pace, R. 1997d. “Sparse spatial autoregressions.” <em>Statistics &amp; Probability Letters</em> 33 (3): 291–97.</p>
</div>
<div id="ref-pace+lesage:08">
<p>Pace, RK, and JP LeSage. 2008. “A Spatial Hausman Test.” <em>Economics Letters</em> 101: 282–84.</p>
</div>
<div id="ref-R:Pinheiro+Bates:2000">
<p>Pinheiro, Jose C., and Douglas M. Bates. 2000. <em>Mixed-Effects Models in S and S-Plus</em>. New York: Springer.</p>
</div>
<div id="ref-piras:10">
<p>Piras, Gianfranco. 2010. “sphet: Spatial Models with Heteroskedastic Innovations in R.” <em>Journal of Statistical Software</em> 35 (1): 1–21.</p>
</div>
<div id="ref-ripley:81">
<p>Ripley, B. D. 1981. <em>Spatial Statistics</em>. New York: Wiley.</p>
</div>
<div id="ref-ripley:88">
<p>Ripley, B. 1988. <em>Statistical Inference for Spatial Processes</em>. Cambridge: Cambridge University Press.</p>
</div>
<div id="ref-smith+lee12">
<p>Smith, T. E., and K. L. Lee. 2012. “The effects of spatial autoregressive dependencies on inference in ordinary least squares: a geometric approach.” <em>Journal of Geographical Systems</em> 14 (January): 91–124. <a href="https://doi.org/10.1007/s10109-011-0152-x">https://doi.org/10.1007/s10109-011-0152-x</a>.</p>
</div>
<div id="ref-smith:09">
<p>Smith, Tony E. 2009. “Estimation Bias in Spatial Models with Strongly Connected Weight Matrices.” <em>Geographical Analysis</em> 41 (3): 307–32. <a href="https://doi.org/10.1111/j.1538-4632.2009.00758.x">https://doi.org/10.1111/j.1538-4632.2009.00758.x</a>.</p>
</div>
<div id="ref-suesse:18">
<p>Suesse, Thomas. 2018. “Marginal Maximum Likelihood Estimation of Sar Models with Missing Data.” <em>Computational Statistics &amp; Data Analysis</em> 120: 98–110. <a href="https://doi.org/https://doi.org/10.1016/j.csda.2017.11.004">https://doi.org/https://doi.org/10.1016/j.csda.2017.11.004</a>.</p>
</div>
<div id="ref-umlaufetal:15">
<p>Umlauf, Nikolaus, Daniel Adler, Thomas Kneib, Stefan Lang, and Achim Zeileis. 2015. “Structured Additive Regression Models: An R Interface to BayesX.” <em>Journal of Statistical Software</em> 63 (21): 1–46. <a href="http://www.jstatsoft.org/v63/i21/">http://www.jstatsoft.org/v63/i21/</a>.</p>
</div>
<div id="ref-wagner+zeileis:19">
<p>Wagner, Martin, and Achim Zeileis. 2019. “Heterogeneity and Spatial Dependence of Regional Growth in the EU: A Recursive Partitioning Approach.” <em>German Economic Review</em> 20 (1): 67–82. <a href="https://doi.org/10.1111/geer.12146">https://doi.org/10.1111/geer.12146</a>.</p>
</div>
<div id="ref-wall:04">
<p>Wall, M. M. 2004. “A Close Look at the Spatial Structure Implied by the CAR and SAR Models.” <em>Journal of Statistical Planning and Inference</em> 121: 311–24.</p>
</div>
<div id="ref-WallerGotway:2004">
<p>Waller, Lance A., and Carol A. Gotway. 2004. <em>Applied Spatial Statistics for Public Health Data</em>. Hoboken, NJ: John Wiley &amp; Sons.</p>
</div>
<div id="ref-whittle:54">
<p>Whittle, P. 1954. “On Stationary Processes in the Plane.” <em>Biometrika</em> 41 (3-4): 434–49. <a href="https://doi.org/10.1093/biomet/41.3-4.434">https://doi.org/10.1093/biomet/41.3-4.434</a>.</p>
</div>
<div id="ref-RJ-2013-013">
<p>Wilhelm, Stefan, and Miguel Godinho de Matos. 2013. “Estimating Spatial Probit Models in R.” <em>The R Journal</em> 5 (1): 130–43. <a href="https://doi.org/10.32614/RJ-2013-013">https://doi.org/10.32614/RJ-2013-013</a>.</p>
</div>
<div id="ref-wood:17">
<p>Wood, S.N. 2017. <em>Generalized Additive Models: An Introduction with R</em>. 2nd ed. Chapman; Hall/CRC.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="area.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="sp-and-raster.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": false
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/edzer/sdsr/edit/master/18-SpatialRegression.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
